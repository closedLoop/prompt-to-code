{"lang": "python3", "question_id": 4, "question_slug": "median-of-two-sorted-arrays", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "96 ms", "memory": 14056000, "question_id": "4", "elapsed_time": 104, "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681357670396, "total_correct": 2094, "total_testcases": 2094, "runtime_percentile": 52.89359999999996, "status_memory": "14.1 MB", "memory_percentile": 93.4442, "pretty_lang": "Python3", "submission_id": "932846161", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        merged_list = sorted(nums1 + nums2)\n        mid = len(merged_list) // 2\n        \n        if len(merged_list) % 2 == 0:\n            return (merged_list[mid-1] + merged_list[mid]) / 2\n        else:\n            return float(merged_list[mid])"}
{"lang": "python3", "question_id": 4, "question_slug": "median-of-two-sorted-arrays", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "105 ms", "memory": 14060000, "question_id": "4", "elapsed_time": 113, "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681357894899, "total_correct": 2094, "total_testcases": 2094, "runtime_percentile": 16.51259999999995, "status_memory": "14.1 MB", "memory_percentile": 93.4442, "pretty_lang": "Python3", "submission_id": "932847654", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        merged = []\n        i = j = 0\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                merged.append(nums1[i])\n                i += 1\n            else:\n                merged.append(nums2[j])\n                j += 1\n                \n        merged.extend(nums1[i:])\n        merged.extend(nums2[j:])\n        \n        n = len(merged)\n        \n        if n % 2 == 0:\n            return (merged[n // 2 - 1] + merged[n // 2]) / 2\n        else:\n            return merged[n // 2]"}
{"lang": "python3", "question_id": 10, "question_slug": "regular-expression-matching", "status": "Submission Timed-Out", "reward": false, "done": false, "submission_result": {"state": "STARTED"}, "code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        if not p:\n            return not s\n\n        first_match = False\n        if s:\n            first_match = p[0] in {s[0], '.'}\n\n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}
{"lang": "python3", "question_id": 23, "question_slug": "merge-k-sorted-lists", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "92 ms", "memory": 18172000, "question_id": "23", "elapsed_time": 111, "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681358291268, "total_correct": 133, "total_testcases": 133, "runtime_percentile": 91.54820000000001, "status_memory": "18.2 MB", "memory_percentile": 38.85120000000001, "pretty_lang": "Python3", "submission_id": "932850158", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List, Optional\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if not lists:\n            return None\n\n        nodes = []\n        for head in lists:\n            current = head\n            while current:\n                nodes.append(current.val)\n                current = current.next\n\n        nodes.sort()\n        dummy = ListNode()\n        cur = dummy\n        for value in nodes:\n            cur.next = ListNode(value)\n            cur = cur.next\n\n        return dummy.next"}
{"lang": "python3", "question_id": 25, "question_slug": "reverse-nodes-in-k-group", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "36 ms", "memory": 15144000, "question_id": "25", "elapsed_time": 61, "compare_result": "11111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681358690490, "total_correct": 62, "total_testcases": 62, "runtime_percentile": 99.49139999999998, "status_memory": "15.1 MB", "memory_percentile": 74.77639999999998, "pretty_lang": "Python3", "submission_id": "932852710", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import Optional\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n        \nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        # Find the length of the list\n        length = 0\n        current = head\n        while current:\n            length += 1\n            current = current.next\n\n        # If the list has only one element or k=1, return the head as it is.\n        if length < 2 or k == 1:\n            return head\n        \n        dummy = ListNode(0, head)\n        prev_group = dummy\n        current_node = head\n        \n        for _ in range(length // k):  # Number of k groups\n            last_in_prev_group = prev_group\n            first_in_curr_group = current_node\n            \n            # Reverse the k group\n            for _ in range(k):\n                next_node = current_node.next\n                current_node.next = prev_group\n                prev_group = current_node\n                current_node = next_node\n                \n            last_in_prev_group.next = prev_group\n            first_in_curr_group.next = current_node\n            prev_group = first_in_curr_group\n            \n        return dummy.next"}
{"lang": "python3", "question_id": 30, "question_slug": "substring-with-concatenation-of-all-words", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "490 ms", "memory": 14284000, "question_id": "30", "elapsed_time": 510, "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681358951638, "total_correct": 178, "total_testcases": 178, "runtime_percentile": 49.27220000000055, "status_memory": "14.3 MB", "memory_percentile": 28.64779999999999, "pretty_lang": "Python3", "submission_id": "932854426", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:\n            return []\n\n        word_length = len(words[0])\n        words_count = len(words)\n        total_length = word_length * words_count\n        s_length = len(s)\n        words_freq = {}\n\n        for word in words:\n            words_freq[word] = words_freq.get(word, 0) + 1\n\n        result = []\n        \n        for i in range(s_length - total_length + 1):\n            curr_freq = {}\n            for j in range(i, i + total_length, word_length):\n                curr_word = s[j:j + word_length]\n                if curr_word in words_freq:\n                    curr_freq[curr_word] = curr_freq.get(curr_word, 0) + 1\n                else:\n                    break\n\n            if curr_freq == words_freq:\n                result.append(i)\n\n        return result"}
{"lang": "python3", "question_id": 32, "question_slug": "longest-valid-parentheses", "status": "Runtime Error", "reward": false, "done": false, "submission_result": {"status_code": 15, "lang": "python3", "run_success": false, "runtime_error": "Line 40: NameError: name 'Solution' is not defined", "full_runtime_error": "NameError: name 'Solution' is not defined\n    ret = Solution().longestValidParentheses(param_1)\nLine 40 in _driver (Solution.py)\n    _driver()\nLine 51 in <module> (Solution.py)", "status_runtime": "N/A", "memory": 13892000, "question_id": "32", "elapsed_time": 43, "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "code_output": "", "std_output": "", "last_testcase": "\"(()\"", "expected_output": "2", "task_finish_time": 1681359031184, "total_correct": 0, "total_testcases": 231, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "932854943", "status_msg": "Runtime Error", "state": "SUCCESS"}, "code": "\ndef longest_valid_parentheses(s: str) -> int:\n    stack = []\n    max_length = 0\n    last_invalid = -1\n\n    for i, char in enumerate(s):\n        if char == \"(\":\n            stack.append(i)\n        else:\n            if not stack:\n                last_invalid = i\n            else:\n                stack.pop()\n                if not stack:\n                    max_length = max(max_length, i - last_invalid)\n                else:\n                    max_length = max(max_length, i - stack[-1])\n\n    return max_length\n"}
{"lang": "python3", "question_id": 37, "question_slug": "sudoku-solver", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "563 ms", "memory": 13796000, "question_id": "37", "elapsed_time": 572, "compare_result": "111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681359280504, "total_correct": 6, "total_testcases": 6, "runtime_percentile": 27.975499999999403, "status_memory": "13.8 MB", "memory_percentile": 99.4297, "pretty_lang": "Python3", "submission_id": "932856719", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        def is_valid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[(row//3)*3 + i//3][(col//3)*3 + i%3] == num:\n                    return False\n            return True\n\n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == \".\":\n                        for num in \"123456789\":\n                            if is_valid(board, i, j, num):\n                                board[i][j] = num\n                                if solve(board):\n                                    return True\n                                else:\n                                    board[i][j] = \".\"\n                        return False\n            return True\n\n        solve(board)"}
{"lang": "python3", "question_id": 41, "question_slug": "first-missing-positive", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "418 ms", "memory": 27800000, "question_id": "41", "elapsed_time": 447, "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681359504989, "total_correct": 175, "total_testcases": 175, "runtime_percentile": 24.430600000000023, "status_memory": "27.8 MB", "memory_percentile": 57.186099999999996, "pretty_lang": "Python3", "submission_id": "932858176", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        # Ensure 1 is in the list, if not return 1\n        if 1 not in nums:\n            return 1\n\n        # Replace negative numbers with 1\n        for i in range(len(nums)):\n            if nums[i] <= 0:\n                nums[i] = 1\n\n        # Mark visited positive integers as negative (use index - 1)\n        for num in nums:\n            index = abs(num) - 1\n\n            if index < len(nums):\n                nums[index] = - abs(nums[index])\n\n        # Find the first positive integer\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                return i + 1\n\n        # If all integers are negative, return list length + 1\n        return len(nums) + 1"}
{"lang": "python3", "question_id": 42, "question_slug": "trapping-rain-water", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "145 ms", "memory": 15936000, "question_id": "42", "elapsed_time": 187, "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681359723235, "total_correct": 322, "total_testcases": 322, "runtime_percentile": 32.70209999999999, "status_memory": "15.9 MB", "memory_percentile": 73.38410000000002, "pretty_lang": "Python3", "submission_id": "932859653", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        if not height:\n            return 0\n        \n        left_max = [0] * len(height)\n        right_max = [0] * len(height)\n        \n        left_max[0] = height[0]\n        for i in range(1, len(height)):\n            left_max[i] = max(height[i], left_max[i-1])\n            \n        right_max[-1] = height[-1]\n        for i in range(len(height) - 2, -1, -1):\n            right_max[i] = max(height[i], right_max[i+1])\n            \n        trapped_water = 0\n        for i in range(len(height)):\n            trapped_water += min(left_max[i], right_max[i]) - height[i]\n            \n        return trapped_water"}
{"lang": "python3", "question_id": 44, "question_slug": "wildcard-matching", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "770 ms", "memory": 22420000, "question_id": "44", "elapsed_time": 813, "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681359823358, "total_correct": 1811, "total_testcases": 1811, "runtime_percentile": 45.52930000000081, "status_memory": "22.4 MB", "memory_percentile": 51.09560000000003, "pretty_lang": "Python3", "submission_id": "932860289", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = True\n        \n        for j in range(1, len(p) + 1):\n            if p[j-1] == '*':\n                dp[0][j] = dp[0][j - 1]\n                \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i][j-1] or dp[i-1][j]\n                elif p[j-1] == '?' or p[j-1] == s[i-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                    \n        return dp[len(s)][len(p)]\n"}
{"lang": "python3", "question_id": 51, "question_slug": "n-queens", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "49 ms", "memory": 14344000, "question_id": "51", "elapsed_time": 65, "compare_result": "111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681360144126, "total_correct": 9, "total_testcases": 9, "runtime_percentile": 89.79969999999999, "status_memory": "14.3 MB", "memory_percentile": 78.2116, "pretty_lang": "Python3", "submission_id": "932862459", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        \n        def is_not_under_attack(row, col):\n            return not (rows[col] or hills[row - col] or dales[row + col])\n        \n        def place_queen(row, col):\n            rows[col] = 1\n            hills[row - col] = 1\n            dales[row + col] = 1\n            board[row][col] = \"Q\"\n        \n        def remove_queen(row, col):\n            rows[col] = 0\n            hills[row - col] = 0\n            dales[row + col] = 0\n            board[row][col] = \".\"\n        \n        def backtrack(row):\n            if row == n:\n                result.append([\"\".join(row) for row in board])\n                return\n            \n            for col in range(n):\n                if is_not_under_attack(row, col):\n                    place_queen(row, col)\n                    backtrack(row + 1)\n                    remove_queen(row, col)\n\n        # Initialize variables\n        rows = [0] * n\n        hills = [0] * (2 * n - 1)\n        dales = [0] * (2 * n - 1)\n        board = [[\".\"] * n for _ in range(n)]\n        result = []\n        # Start DFS to search for valid solutions\n        backtrack(0)\n        \n        return result"}
{"lang": "python3", "question_id": 52, "question_slug": "n-queens-ii", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "93 ms", "memory": 13832000, "question_id": "52", "elapsed_time": 113, "compare_result": "111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681360262909, "total_correct": 9, "total_testcases": 9, "runtime_percentile": 24.836400000000047, "status_memory": "13.8 MB", "memory_percentile": 68.5448, "pretty_lang": "Python3", "submission_id": "932863189", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        def isValid(queens, row, col):\n            for r, c in enumerate(queens[:row]):\n                if c == col or r - c == row - col or r + c == row + col:\n                    return False\n            return True\n\n        def backtrack(row, queens):\n            if row == n:\n                nonlocal count\n                count += 1\n                return\n            \n            for col in range(n):\n                if isValid(queens, row, col):\n                    queens[row] = col\n                    backtrack(row + 1, queens)\n\n        count = 0\n        backtrack(0, [None] * n)\n        return count"}
{"lang": "python3", "question_id": 60, "question_slug": "permutation-sequence", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "32 ms", "memory": 13872000, "question_id": "60", "elapsed_time": 44, "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681360330929, "total_correct": 200, "total_testcases": 200, "runtime_percentile": 73.77880000000002, "status_memory": "13.9 MB", "memory_percentile": 66.954, "pretty_lang": "Python3", "submission_id": "932863608", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "import math\n\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        numbers = list(range(1, n + 1))\n        permutation = \"\"\n        k -= 1\n\n        while n > 0:\n            n -= 1\n            index, k = divmod(k, math.factorial(n))\n            permutation += str(numbers.pop(index))\n        \n        return permutation"}
{"lang": "python3", "question_id": 65, "question_slug": "valid-number", "status": "Wrong Answer", "reward": false, "done": false, "submission_result": {"status_code": 11, "lang": "python3", "run_success": true, "status_runtime": "N/A", "memory": 14012000, "question_id": "65", "elapsed_time": 52, "compare_result": "110111101111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111001", "code_output": "true", "std_output": "", "last_testcase": "\".\"", "expected_output": "false", "task_finish_time": 1681360475577, "total_correct": 1483, "total_testcases": 1491, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "932864516", "input_formatted": "\".\"", "input": "\".\"", "status_msg": "Wrong Answer", "state": "SUCCESS"}, "code": "\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        \"\"\"\n        Check if the given string is a valid number based on the conditions provided in the prompt.\n\n        Args:\n        s (str): A string containing the potential number.\n\n        Returns:\n        bool: Returns True if valid number, False otherwise.\n        \"\"\"\n\n        i = 0\n\n        # Check for optional sign\n        if i < len(s) and (s[i] == '+' or s[i] == '-'):\n            i += 1\n\n        # Check for digits\n        has_digits = False\n        while i < len(s) and s[i].isdigit():\n            i += 1\n            has_digits = True\n\n        # Check for optional dot and digits after dot\n        if i < len(s) and s[i] == '.':\n            i += 1\n            while i < len(s) and s[i].isdigit():\n                i += 1\n                has_digits = True\n\n        # Check for optional 'e' or 'E' followed by optional sign and digits\n        if i < len(s) and (s[i] == 'e' or s[i] == 'E'):\n            if not has_digits:\n                return False\n\n            i += 1\n            if i < len(s) and (s[i] == '+' or s[i] == '-'):\n                i += 1\n\n            has_digits_after_e = False\n            while i < len(s) and s[i].isdigit():\n                i += 1\n                has_digits_after_e = True\n\n            if not has_digits_after_e:\n                return False\n\n        return i == len(s)\n"}
{"lang": "python3", "question_id": 68, "question_slug": "text-justification", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "31 ms", "memory": 13824000, "question_id": "68", "elapsed_time": 43, "compare_result": "111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681360876176, "total_correct": 27, "total_testcases": 27, "runtime_percentile": 76.5365, "status_memory": "13.8 MB", "memory_percentile": 82.41899999999998, "pretty_lang": "Python3", "submission_id": "932867146", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        res, cur, num_of_letters = [], [], 0\n        for w in words:\n            if num_of_letters + len(w) + len(cur) > maxWidth:\n                for i in range(maxWidth - num_of_letters):\n                    cur[i%(len(cur)-1 or 1)] += ' '\n                res.append(''.join(cur))\n                cur, num_of_letters = [], 0\n            cur += [w]\n            num_of_letters += len(w)\n        return res + [' '.join(cur).ljust(maxWidth)]"}
{"lang": "python3", "question_id": 72, "question_slug": "edit-distance", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "161 ms", "memory": 17648000, "question_id": "72", "elapsed_time": 221, "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681360982614, "total_correct": 1146, "total_testcases": 1146, "runtime_percentile": 60.33019999999995, "status_memory": "17.6 MB", "memory_percentile": 24.952700000000018, "pretty_lang": "Python3", "submission_id": "932867822", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        if not word1 or not word2:\n            return max(len(word1), len(word2))\n\n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n\n        return dp[m][n]\n"}
{"lang": "python3", "question_id": 76, "question_slug": "minimum-window-substring", "status": "Runtime Error", "reward": false, "done": false, "submission_result": {"status_code": 15, "lang": "python3", "run_success": false, "runtime_error": "Line 55: NameError: name 'Solution' is not defined", "full_runtime_error": "NameError: name 'Solution' is not defined\n    ret = Solution().minWindow(param_1, param_2)\nLine 55 in _driver (Solution.py)\n    _driver()\nLine 66 in <module> (Solution.py)", "status_runtime": "N/A", "memory": 13920000, "question_id": "76", "elapsed_time": 42, "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "code_output": "", "std_output": "", "last_testcase": "\"ADOBECODEBANC\"\n\"ABC\"", "expected_output": "\"BANC\"", "task_finish_time": 1681361119887, "total_correct": 0, "total_testcases": 267, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "932868740", "status_msg": "Runtime Error", "state": "SUCCESS"}, "code": "\ndef minWindow(s: str, t: str) -> str:\n    t_char_count = {}\n    for char in t:\n        t_char_count[char] = t_char_count.get(char, 0) + 1\n\n    required = len(t)\n    left, right = 0, 0\n    min_len, min_window = float(\"inf\"), \"\"\n\n    while right < len(s):\n        if s[right] in t_char_count:\n            if t_char_count[s[right]] > 0:\n                required -= 1\n            t_char_count[s[right]] -= 1\n\n        while required == 0:\n            if right - left + 1 < min_len:\n                min_len = right - left + 1\n                min_window = s[left:right+1]\n\n            if s[left] in t_char_count:\n                t_char_count[s[left]] += 1\n                if t_char_count[s[left]] > 0:\n                    required += 1\n            left += 1\n\n        right += 1\n\n    return min_window\n"}
{"lang": "python3", "question_id": 84, "question_slug": "largest-rectangle-in-histogram", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "979 ms", "memory": 28524000, "question_id": "84", "elapsed_time": 1015, "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681361336478, "total_correct": 98, "total_testcases": 98, "runtime_percentile": 62.5292999999997, "status_memory": "28.5 MB", "memory_percentile": 55.27039999999995, "pretty_lang": "Python3", "submission_id": "932870118", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        # Start by pushing -1 onto the stack\n        stack = [-1]\n        max_area = 0\n        \n        for i in range(len(heights)):\n            # If the next height is lower than the stack top height, we need to pop the stack,\n            # and calculate the area for the popped height\n            while stack[-1] != -1 and heights[i] <= heights[stack[-1]]:\n                height = heights[stack.pop()]\n                width = i - stack[-1] - 1\n                max_area = max(max_area, height * width)\n                \n            stack.append(i) # Finally, push the current height onto the stack\n        \n        # Pop the remaining heights from the stack and calculate their areas\n        while stack[-1] != -1:\n            height = heights[stack.pop()]\n            width = len(heights) - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        \n        return max_area"}
{"lang": "python3", "question_id": 85, "question_slug": "maximal-rectangle", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "251 ms", "memory": 15128000, "question_id": "85", "elapsed_time": 265, "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681361712428, "total_correct": 74, "total_testcases": 74, "runtime_percentile": 88.09300000000006, "status_memory": "15.1 MB", "memory_percentile": 81.76520000000001, "pretty_lang": "Python3", "submission_id": "932872771", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if not matrix or not matrix[0]:\n            return 0\n\n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * (n + 1)\n        max_area = 0\n\n        for i in range(m):\n            for j in range(n):\n                heights[j] = heights[j] + 1 if matrix[i][j] == \"1\" else 0\n\n            stack = [-1]\n            for j in range(n + 1):\n                while heights[j] < heights[stack[-1]]:\n                    h = heights[stack.pop()]\n                    w = j - stack[-1] - 1\n                    max_area = max(max_area, h * w)\n                stack.append(j)\n\n        return max_area"}
{"lang": "python3", "question_id": 87, "question_slug": "scramble-string", "status": "Submission Timed-Out", "reward": false, "done": false, "submission_result": {"state": "STARTED"}, "code": "\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if s1 == s2:\n            return True\n        if sorted(s1) != sorted(s2):\n            return False\n\n        for i in range(1, len(s1)):\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or \\\n               (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\n                return True\n\n        return False\n"}
{"lang": "python3", "question_id": 99, "question_slug": "recover-binary-search-tree", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "77 ms", "memory": 14232000, "question_id": "99", "elapsed_time": 92, "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681362119707, "total_correct": 1919, "total_testcases": 1919, "runtime_percentile": 39.959799999999994, "status_memory": "14.2 MB", "memory_percentile": 55.48869999999999, "pretty_lang": "Python3", "submission_id": "932875653", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def recoverTree(self, root: TreeNode) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n\n        # Helper function for the in-order traversal\n        def in_order_traversal(node):\n            if not node:\n                return\n            in_order_traversal(node.left)\n            if self.first_node is None and self.prev_node.val >= node.val:\n                self.first_node = self.prev_node\n            if self.first_node and self.prev_node.val >= node.val:\n                self.second_node = node\n            self.prev_node = node\n            in_order_traversal(node.right)\n\n        # Initialize the first, second, and previous nodes\n        self.first_node = None\n        self.second_node = None\n        self.prev_node = TreeNode(float('-inf'))\n\n        # Perform in-order traversal to find the swapped nodes\n        in_order_traversal(root)\n\n        # Swap the values of the first and second node\n        self.first_node.val, self.second_node.val = self.second_node.val, self.first_node.val"}
{"lang": "python3", "question_id": 115, "question_slug": "distinct-subsequences", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "608 ms", "memory": 70528000, "question_id": "115", "elapsed_time": 674, "compare_result": "11111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681362206397, "total_correct": 65, "total_testcases": 65, "runtime_percentile": 58.6934000000002, "status_memory": "70.5 MB", "memory_percentile": 56.63810000000007, "pretty_lang": "Python3", "submission_id": "932876231", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "\nclass Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        # Create a matrix to store the intermediate results\n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n\n        # Initialize the first column to 1\n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n\n        # Fill in the matrix\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n\n        return dp[-1][-1]\n"}
{"lang": "python3", "question_id": 123, "question_slug": "best-time-to-buy-and-sell-stock-iii", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "1393 ms", "memory": 28904000, "question_id": "123", "elapsed_time": 1429, "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681362427935, "total_correct": 214, "total_testcases": 214, "runtime_percentile": 43.923499999999876, "status_memory": "28.9 MB", "memory_percentile": 36.601500000000016, "pretty_lang": "Python3", "submission_id": "932877811", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if not prices:\n            return 0\n\n        n = len(prices)\n        k = 2 # maximum transactions\n\n        dp = [[0] * (n) for _ in range(k + 1)]\n\n        for i in range(1, k + 1):\n            max_diff = -prices[0]\n            for j in range(1, n):\n                dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n                max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n\n        return dp[-1][-1]"}
{"lang": "python3", "question_id": 124, "question_slug": "binary-tree-maximum-path-sum", "status": "Wrong Answer", "reward": false, "done": false, "submission_result": {"status_code": 11, "lang": "python3", "run_success": true, "status_runtime": "N/A", "memory": 21908000, "question_id": "124", "elapsed_time": 109, "compare_result": "00111110011001010100000101000001000110110111010000010000100001010000100101000010000000000000000", "code_output": "4", "std_output": "", "last_testcase": "[1,2,3]", "expected_output": "6", "task_finish_time": 1681362962689, "total_correct": 29, "total_testcases": 95, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "932881720", "input_formatted": "[1,2,3]", "input": "[1,2,3]", "status_msg": "Wrong Answer", "state": "SUCCESS"}, "code": "# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def maxPathSum(self, root: TreeNode) -> int:\n        _, max_sum = self._maxPathSum_and_node_value_sum(root)\n        return max_sum\n\n    def _maxPathSum_and_node_value_sum(self, root: TreeNode):\n        if root is None:\n            return -1001, -1001\n\n        left_max_path, left_node_sum = self._maxPathSum_and_node_value_sum(root.left)\n        right_max_path, right_node_sum = self._maxPathSum_and_node_value_sum(root.right)\n\n        max_path = max(left_max_path, right_max_path, root.val, left_node_sum + root.val, right_node_sum + root.val,\n                       left_node_sum + right_node_sum + root.val)\n\n        node_value_sum = max(left_node_sum + root.val, right_node_sum + root.val, root.val)\n\n        return max_path, node_value_sum"}
{"lang": "python3", "question_id": 126, "question_slug": "word-ladder-ii", "status": "Wrong Answer", "reward": false, "done": false, "submission_result": {"status_code": 11, "lang": "python3", "run_success": true, "status_runtime": "N/A", "memory": 783020000, "question_id": "126", "elapsed_time": 3727, "compare_result": "010100000000001000000000000000000000", "code_output": "[]", "std_output": "", "last_testcase": "\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]", "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]", "task_finish_time": 1681363287812, "total_correct": 3, "total_testcases": 36, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "932883999", "input_formatted": "\"hit\", \"cog\", [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]", "input": "\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]", "status_msg": "Wrong Answer", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        # check if endWord is in wordList, if not, return empty list\n        if endWord not in wordList:\n            return []\n        \n        # use a dictionary to store word combinations\n        word_combinations = {}\n        word_combinations[endWord] = [[endWord]]\n        \n        # create a set of unvisited words\n        unvisited_words = set(wordList)\n        unvisited_words.discard(endWord)\n        \n        # loop through the words in the word_combinations\n        while word_combinations:\n            new_word_combinations = {}\n            current_unvisited_words = set()\n            \n            for word in word_combinations:\n                for i in range(len(beginWord)):\n                    for c in \"abcdefghijklmnopqrstuvwxyz\":\n                        if c != word[i]:\n                            new_word = word[:i] + c + word[i+1:]\n                            if new_word in unvisited_words:\n                                current_unvisited_words.add(new_word)\n                                if new_word in new_word_combinations:\n                                    new_word_combinations[new_word].extend([seq + [new_word] for seq in word_combinations[word]])\n                                else:\n                                    new_word_combinations[new_word] = [seq + [new_word] for seq in word_combinations[word]]\n                            \n            # update the unvisited_words with the current_unvisited_words\n            unvisited_words.difference_update(current_unvisited_words)\n            \n            # if beginWord is found in new_word_combinations then return its value\n            if beginWord in new_word_combinations:\n                return new_word_combinations[beginWord]\n\n            # update word_combinations with the new_word_combinations\n            word_combinations = new_word_combinations\n            \n        return []"}
{"lang": "python3", "question_id": 127, "question_slug": "word-ladder", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "103 ms", "memory": 14992000, "question_id": "127", "elapsed_time": 111, "compare_result": "11111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681363585152, "total_correct": 50, "total_testcases": 50, "runtime_percentile": 96.65110000000003, "status_memory": "15 MB", "memory_percentile": 90.292, "pretty_lang": "Python3", "submission_id": "932886268", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return 0\n        \n        front_level = {beginWord}\n        back_level = {endWord}\n        level = 1\n        # letters for generating child words\n        letters = [chr(ord('a') + i) for i in range(26)]\n\n        while front_level and back_level:\n            # Always expand the smaller level\n            if len(front_level) > len(back_level):\n                front_level, back_level = back_level, front_level\n\n            # Placeholder for the next level of BFS\n            next_level = set()\n\n            # Remove words from the wordSet to avoid cycles\n            wordSet -= front_level\n\n            for word in front_level:\n\n                # Generate all valid child words\n                for i in range(len(beginWord)):\n                    for char in letters:\n                        child_word = word[:i] + char + word[i+1:]\n\n                        # If a valid child_word exists in the back_level, we have a valid transformation\n                        if child_word in back_level:\n                            return level + 1\n\n                        # If a valid child_word only exists in the wordSet, save it for future expansions\n                        if child_word in wordSet:\n                            next_level.add(child_word)\n\n            # Update the front_level for the next level of BFS\n            front_level = next_level\n            level += 1\n\n        return 0"}
{"lang": "python3", "question_id": 128, "question_slug": "longest-consecutive-sequence", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "321 ms", "memory": 28928000, "question_id": "128", "elapsed_time": 342, "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681363794641, "total_correct": 72, "total_testcases": 72, "runtime_percentile": 79.25060000000006, "status_memory": "28.9 MB", "memory_percentile": 55.19370000000002, "pretty_lang": "Python3", "submission_id": "932887725", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n\n        nums_set = set(nums)\n        longest_sequence = 0\n\n        for num in nums_set:\n            if num - 1 not in nums_set:\n                current_num = num\n                current_sequence = 1\n\n                while current_num + 1 in nums_set:\n                    current_num += 1\n                    current_sequence += 1\n\n                longest_sequence = max(longest_sequence, current_sequence)\n\n        return longest_sequence"}
{"lang": "python3", "question_id": 132, "question_slug": "palindrome-partitioning-ii", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "2362 ms", "memory": 13960000, "question_id": "132", "elapsed_time": 2429, "compare_result": "111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681363906017, "total_correct": 36, "total_testcases": 36, "runtime_percentile": 19.362600000000537, "status_memory": "14 MB", "memory_percentile": 78.23899999999999, "pretty_lang": "Python3", "submission_id": "932888513", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "\nclass Solution:\n    def minCut(self, s: str) -> int:\n        def is_palindrome(s: str) -> bool:\n            return s == s[::-1]\n\n        n = len(s)\n        cut = [0] * n\n\n        for i in range(n):\n            if is_palindrome(s[:i + 1]):\n                cut[i] = 0\n            else:\n                cut[i] = cut[i - 1] + 1\n                for j in range(1, i):\n                    if is_palindrome(s[j:i + 1]):\n                        cut[i] = min(cut[i], cut[j - 1] + 1)\n        return cut[-1]\n"}
{"lang": "python3", "question_id": 135, "question_slug": "candy", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "167 ms", "memory": 16796000, "question_id": "135", "elapsed_time": 179, "compare_result": "111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681364086780, "total_correct": 48, "total_testcases": 48, "runtime_percentile": 54.872400000000006, "status_memory": "16.8 MB", "memory_percentile": 61.3942, "pretty_lang": "Python3", "submission_id": "932889844", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        candies = [1] * len(ratings)\n        \n        for i in range(1, len(ratings)):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n                \n        for i in range(len(ratings) - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n                \n        return sum(candies)"}
{"lang": "python3", "question_id": 140, "question_slug": "word-break-ii", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "23 ms", "memory": 13836000, "question_id": "140", "elapsed_time": 43, "compare_result": "11111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681364245369, "total_correct": 26, "total_testcases": 26, "runtime_percentile": 97.39920000000002, "status_memory": "13.8 MB", "memory_percentile": 68.6996, "pretty_lang": "Python3", "submission_id": "932890942", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n\n        def backtrack(start: int):\n            if start == len(s):\n                return [[]]\n            sub_solutions = []\n            for end in range(start + 1, len(s) + 1):\n                if s[start:end] in wordDict:\n                    for sub_solution in backtrack(end):\n                        sub_solutions.append([s[start:end]] + sub_solution)\n            return sub_solutions\n        \n        return [\" \".join(words) for words in backtrack(0)]"}
{"lang": "python3", "question_id": 149, "question_slug": "max-points-on-a-line", "status": "Runtime Error", "reward": false, "done": false, "submission_result": {"status_code": 15, "lang": "python3", "run_success": false, "runtime_error": "Line 65: NameError: name 'Solution' is not defined", "full_runtime_error": "NameError: name 'Solution' is not defined\n    ret = Solution().maxPoints(param_1)\nLine 65 in _driver (Solution.py)\n    _driver()\nLine 76 in <module> (Solution.py)", "status_runtime": "N/A", "memory": 13944000, "question_id": "149", "elapsed_time": 42, "compare_result": "00000000000000000000000000000000000000000", "code_output": "", "std_output": "", "last_testcase": "[[1,1],[2,2],[3,3]]", "expected_output": "3", "task_finish_time": 1681364426249, "total_correct": 0, "total_testcases": 41, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "932892221", "status_msg": "Runtime Error", "state": "SUCCESS"}, "code": "from typing import List\n\ndef maxPoints(points: List[List[int]]) -> int:\n    # Create a function definition to help calculate gcd of two numbers\n    def gcd(x, y):\n        return x if y == 0 else gcd(y, x % y)\n\n    n = len(points)\n    if n <= 2:\n        return n\n\n    max_points = 0\n\n    for i in range(n):\n        slope_count = {}\n        same = 0\n        local_max = 0\n\n        for j in range(i+1, n):\n            # Calculate deltaX and deltaY\n            dx = points[i][0] - points[j][0]\n            dy = points[i][1] - points[j][1]\n            # Handle points with same coordinates\n            if dx == 0 and dy == 0:\n                same += 1\n                continue\n\n            # Calculate greatest common divisor\n            g = gcd(dx, dy)\n            if g != 0:\n                dx //= g\n                dy //= g\n\n            # Use tuple to represent the slope\n            slope = (dx, dy)\n            # Count the points with same slope\n            if slope in slope_count:\n                slope_count[slope] += 1\n            else:\n                slope_count[slope] = 1\n\n            local_max = max(local_max, slope_count[slope])\n\n        max_points = max(max_points, local_max + same + 1)\n\n    return max_points"}
{"lang": "python3", "question_id": 154, "question_slug": "find-minimum-in-rotated-sorted-array-ii", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "55 ms", "memory": 14364000, "question_id": "154", "elapsed_time": 68, "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681364623695, "total_correct": 193, "total_testcases": 193, "runtime_percentile": 56.740000000000016, "status_memory": "14.4 MB", "memory_percentile": 73.929, "pretty_lang": "Python3", "submission_id": "932893709", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        start, end = 0, len(nums) - 1\n        while start < end:\n            mid = start + (end - start) // 2\n            if nums[mid] > nums[end]:\n                start = mid + 1\n            elif nums[mid] < nums[end]:\n                end = mid\n            else:\n                end -= 1\n        return nums[start]"}
{"lang": "python3", "question_id": 164, "question_slug": "maximum-gap", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "1044 ms", "memory": 28048000, "question_id": "164", "elapsed_time": 1072, "compare_result": "11111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681364795807, "total_correct": 41, "total_testcases": 41, "runtime_percentile": 74.2710999999999, "status_memory": "28 MB", "memory_percentile": 68.43079999999999, "pretty_lang": "Python3", "submission_id": "932894992", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n\n        def maximum_gap(nums: List[int]) -> int:\n            if len(nums) < 2:\n                return 0\n            nums.sort()\n            max_gap = 0\n            for i in range(1, len(nums)):\n                max_gap = max(max_gap, nums[i] - nums[i-1])\n            return max_gap\n\n        return maximum_gap(nums)"}
{"lang": "python3", "question_id": 174, "question_slug": "dungeon-game", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "74 ms", "memory": 15116000, "question_id": "174", "elapsed_time": 86, "compare_result": "111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681365041598, "total_correct": 45, "total_testcases": 45, "runtime_percentile": 70.4273, "status_memory": "15.1 MB", "memory_percentile": 40.9638, "pretty_lang": "Python3", "submission_id": "932896790", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def calculateMinimumHP(self, dungeon: List[List[int]]) -> int:\n        if not dungeon or not dungeon[0]:\n            return 0\n\n        m, n = len(dungeon), len(dungeon[0])\n        dp = [[0] * n for _ in range(m)]\n\n        # Initialize DP with bottom-right corner\n        dp[-1][-1] = max(1, 1 - dungeon[-1][-1])\n\n        # Initialize last row\n        for i in range(n - 2, -1, -1):\n            dp[-1][i] = max(dp[-1][i + 1] - dungeon[-1][i], 1)\n\n        # Initialize last column\n        for i in range(m - 2, -1, -1):\n            dp[i][-1] = max(dp[i + 1][-1] - dungeon[i][-1], 1)\n\n        # Fill in the rest of the DP table\n        for i in range(m - 2, -1, -1):\n            for j in range(n - 2, -1, -1):\n                dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1)\n\n        return dp[0][0]"}
{"lang": "python3", "question_id": 188, "question_slug": "best-time-to-buy-and-sell-stock-iv", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "147 ms", "memory": 15196000, "question_id": "188", "elapsed_time": 170, "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681365316591, "total_correct": 210, "total_testcases": 210, "runtime_percentile": 69.23859999999989, "status_memory": "15.2 MB", "memory_percentile": 64.49009999999997, "pretty_lang": "Python3", "submission_id": "932898916", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        if not prices:\n            return 0\n\n        if k >= len(prices) // 2:\n            return sum(max(prices[i + 1] - prices[i], 0) for i in range(len(prices) - 1))\n\n        dp = [[0] * len(prices) for _ in range(k + 1)]\n\n        for i in range(1, k + 1):\n            max_diff = -prices[0]\n            for j in range(1, len(prices)):\n                dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n                max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n\n        return dp[k][-1]"}
{"lang": "python3", "question_id": 212, "question_slug": "word-search-ii", "status": "Runtime Error", "reward": false, "done": false, "submission_result": {"status_code": 15, "lang": "python3", "run_success": false, "runtime_error": "Line 1: SyntaxError: invalid syntax", "full_runtime_error": "SyntaxError: invalid syntax\n         ^^^^^^\n    Word Search II:\nLine 1  (Solution.py)", "status_runtime": "N/A", "memory": 9020000, "question_id": "212", "elapsed_time": 16, "compare_result": "00000000000000000000000000000000000000000000000000000000000000000", "code_output": "", "std_output": "", "last_testcase": "[[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]]\n[\"oath\",\"pea\",\"eat\",\"rain\"]", "expected_output": "[\"oath\",\"eat\"]", "task_finish_time": 1681365882313, "total_correct": 0, "total_testcases": 65, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "932903064", "status_msg": "Runtime Error", "state": "SUCCESS"}, "code": "Word Search II:\nGiven an `m x n` `board` of characters and a list of strings `words`, return all words on the board.\n\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\n\nExample 1:\nInput: board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\nOutput: [\"eat\",\"oath\"]\n\nExample 2:\nInput: board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\nOutput: []\n\nConstraints:\n`m == board.length`\n`n == board[i].length`\n`1 <= m, n <= 12`\n`board[i][j]` is a lowercase English letter.\n\n`1 <= words.length <= 3 * 104`\n`1 <= words[i].length <= 10`\n`words[i]` consists of lowercase English letters.\n\nAll the strings of `words` are unique.\n\nCode:\n```python3\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        \n```"}
{"lang": "python3", "question_id": 214, "question_slug": "shortest-palindrome", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "560 ms", "memory": 14228000, "question_id": "214", "elapsed_time": 577, "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681365993652, "total_correct": 121, "total_testcases": 121, "runtime_percentile": 38.59999999999991, "status_memory": "14.2 MB", "memory_percentile": 37.599999999999994, "pretty_lang": "Python3", "submission_id": "932903940", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "\nclass Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        # Move palindrome_check function into Solution class\n        def palindrome_check(s: str) -> bool:\n            return s == s[::-1]\n\n        if palindrome_check(s):\n            return s\n\n        i = len(s)\n        while i > 0:\n            if palindrome_check(s[:i]):\n                break\n            i -= 1\n\n        return s[i:][::-1] + s\n"}
{"lang": "python3", "question_id": 218, "question_slug": "the-skyline-problem", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "114 ms", "memory": 20452000, "question_id": "218", "elapsed_time": 131, "compare_result": "11111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681366292423, "total_correct": 41, "total_testcases": 41, "runtime_percentile": 86.41759999999998, "status_memory": "20.5 MB", "memory_percentile": 15.025399999999983, "pretty_lang": "Python3", "submission_id": "932906314", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\nimport heapq\n\nclass Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        # Sort the building edges (left edge with negative height, right edge with height 0) by their x-coordinate\n        events = sorted([(L, -H, R) for L, R, H in buildings] + [(R, 0, 0) for _, R, _ in buildings])\n        \n        # Initialize the skyline result list and the max-heap (with tuple of negative height and right edge)\n        res, heap = [], [(0, float(\"inf\"))]  \n        \n        # Process each building edge by iterating through the sorted events list\n        for x, negH, R in events:\n            # Remove buildings that have right edge less than or equal to the current x-coordinate\n            while heap[0][1] <= x:  \n                heapq.heappop(heap)\n            \n            # If the current event is a left edge, push it with negative height into the max-heap\n            if negH:\n                heapq.heappush(heap, (negH, R))\n            \n            # If the skyline is empty or its last point has different height than the height of the top element in max-heap\n            if len(res) == 0 or res[-1][1] != -heap[0][0]:\n                res.append([x, -heap[0][0]])  # Add the current point to the skyline result\n        \n        # Return the resulting skyline\n        return res"}
{"lang": "python3", "question_id": 224, "question_slug": "basic-calculator", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "62 ms", "memory": 15356000, "question_id": "224", "elapsed_time": 82, "compare_result": "11111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681366398016, "total_correct": 44, "total_testcases": 44, "runtime_percentile": 97.05889999999998, "status_memory": "15.4 MB", "memory_percentile": 69.5145, "pretty_lang": "Python3", "submission_id": "932907096", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "class Solution:\n    def calculate(self, s: str) -> int:\n        stack = []\n        num = 0\n        sign = 1\n        result = 0\n        \n        for char in s:\n            if char.isdigit():\n                num = num * 10 + int(char)\n            elif char == '+':\n                result += sign * num\n                num = 0\n                sign = 1\n            elif char == '-':\n                result += sign * num\n                num = 0\n                sign = -1\n            elif char == '(':\n                stack.append(result)\n                stack.append(sign)\n                sign = 1\n                result = 0\n            elif char == ')':\n                result += sign * num\n                num = 0\n                result *= stack.pop() # pop sign from stack and multiply\n                result += stack.pop() # pop the last result from the stack and add\n                \n        if num:\n            result += sign * num\n            \n        return result"}
{"lang": "python3", "question_id": 233, "question_slug": "number-of-digit-one", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "33 ms", "memory": 13788000, "question_id": "233", "elapsed_time": 41, "compare_result": "11111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681366496446, "total_correct": 38, "total_testcases": 38, "runtime_percentile": 46.680999999999976, "status_memory": "13.8 MB", "memory_percentile": 96.788, "pretty_lang": "Python3", "submission_id": "932907828", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        ones, m = 0, 1\n        while m <= n:\n            ones += (n // (m * 10)) * m + min(max(n % (m * 10) - m + 1, 0), m)\n            m *= 10\n        return ones\n"}
{"lang": "python3", "question_id": 239, "question_slug": "sliding-window-maximum", "status": "Submission Timed-Out", "reward": false, "done": false, "submission_result": {"state": "STARTED"}, "code": "from typing import List\n\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        if not nums:\n            return []\n        \n        result = []\n        max_idx = -1\n        \n        for i in range(len(nums) - k + 1):\n            if max_idx < i:\n                max_idx = i\n                max_num = nums[i]\n                for j in range(i, i + k):\n                    if nums[j] >= max_num:\n                        max_num = nums[j]\n                        max_idx = j\n            else:\n                if nums[i + k - 1] >= max_num:\n                    max_num = nums[i + k - 1]\n                    max_idx = i + k - 1\n                \n            result.append(max_num)\n        \n        return result"}
{"lang": "python3", "question_id": 273, "question_slug": "integer-to-english-words", "status": "Runtime Error", "reward": false, "done": false, "submission_result": {"status_code": 15, "lang": "python3", "run_success": false, "runtime_error": "Line 1: SyntaxError: invalid syntax", "full_runtime_error": "SyntaxError: invalid syntax\n            ^^\n    Integer to English Words:\nLine 1  (Solution.py)", "status_runtime": "N/A", "memory": 8976000, "question_id": "273", "elapsed_time": 16, "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "code_output": "", "std_output": "", "last_testcase": "123", "expected_output": "\"One Hundred Twenty Three\"", "task_finish_time": 1681367180092, "total_correct": 0, "total_testcases": 601, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "932913073", "status_msg": "Runtime Error", "state": "SUCCESS"}, "code": "Integer to English Words:\nConvert a non-negative integer `num` to its English words representation.\n\n\nExample 1:\nInput: num = 123\nOutput: \"One Hundred Twenty Three\"\n\nExample 2:\nInput: num = 12345\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\n\nExample 3:\nInput: num = 1234567\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n\nExample 4:\nInput: num = 1234567891\nOutput: \"One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One\"\n\nConstraints:\n`0 <= num <= 231 - 1`\n\nCode:\n```python3\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        \n```"}
{"lang": "python3", "question_id": 282, "question_slug": "expression-add-operators", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "727 ms", "memory": 14596000, "question_id": "282", "elapsed_time": 743, "compare_result": "11111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681367820813, "total_correct": 23, "total_testcases": 23, "runtime_percentile": 91.06150000000008, "status_memory": "14.6 MB", "memory_percentile": 99.2424, "pretty_lang": "Python3", "submission_id": "932917865", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        def calculate(i, expr, prev_val, curr_val):\n            # If we have reached the end of the num string\n            if i == len(num):\n                # Check if the evaluated result of the expression is same as target\n                if curr_val == target:\n                    ans.append(expr)\n                return\n            \n            # Iterate through the range of the next indices in the num string\n            for j in range(i+1, len(num) + 1):\n                # Extract the current number as a string and also its integer value\n                curr_num_str = num[i:j]\n                curr_num = int(curr_num_str)\n                \n                # This line checks if there are leading zeroes in the number\n                # If found, then we break the iteration\n                if curr_num_str != str(curr_num):\n                    break\n                \n                # If this is the first number in the expression\n                if i == 0:\n                    # Call calculate with the current number as the new expression\n                    calculate(j, curr_num_str, curr_num, curr_num)\n                else:\n                    # Add '+' and call calculate again with the new expression\n                    calculate(j, expr + \"+\" + curr_num_str, curr_num, curr_val + curr_num)\n                    \n                    # Add '-' and call calculate again with the new expression\n                    calculate(j, expr + \"-\" + curr_num_str, -curr_num, curr_val - curr_num)\n                    \n                    # Add '*' and call calculate again with the new expression\n                    calculate(j, expr + \"*\" + curr_num_str, prev_val * curr_num, curr_val - prev_val + prev_val * curr_num)\n        \n        # Create an empty list to store the answers\n        ans = []\n        # Call the helper function calculate\n        calculate(0, \"\", 0, 0)\n        # Return the list of answers\n        return ans"}
{"lang": "python3", "question_id": 295, "question_slug": "find-median-from-data-stream", "status": "Submission Timed-Out", "reward": false, "done": false, "submission_result": {"state": "STARTED"}, "code": "\nclass MedianFinder:\n\n    def __init__(self):\n        self.data = []\n\n    def addNum(self, num: int) -> None:\n        self.data.append(num)\n        self.data.sort()\n\n    def findMedian(self) -> float:\n        n = len(self.data)\n        if n % 2 == 0:\n            return (self.data[n//2 - 1] + self.data[n//2]) / 2\n        else:\n            return self.data[n//2]\n"}
{"lang": "python3", "question_id": 297, "question_slug": "serialize-and-deserialize-binary-tree", "status": "Runtime Error", "reward": false, "done": false, "submission_result": {"status_code": 15, "lang": "python3", "run_success": false, "runtime_error": "Line 75: Exception: Type <class '__main__.TreeNode'>: Not implemented", "full_runtime_error": "Exception: Type <class '__main__.TreeNode'>: Not implemented\nLine 114 in serialize (./python3/__serializer__.py)\n    out = __Serializer__().serialize(ret, none_str='[]')\nLine 75 in _driver (Solution.py)\n    _driver()\nLine 84 in <module> (Solution.py)", "status_runtime": "N/A", "memory": 13788000, "question_id": "297", "elapsed_time": 42, "compare_result": "0000000000000000000000000000000000000000000000000000", "code_output": "", "std_output": "", "last_testcase": "[1,2,3,null,null,4,5]", "expected_output": "[1,2,3,null,null,4,5]", "task_finish_time": 1681368144291, "total_correct": 0, "total_testcases": 52, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "932920117", "status_msg": "Runtime Error", "state": "SUCCESS"}, "code": "3\n# Definition for a binary tree node.\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return \"null,\"\n        \n        serialized = str(root.val) + \",\"\n        serialized += self.serialize(root.left)\n        serialized += self.serialize(root.right)\n        \n        return serialized\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        values = data.split(',')\n        values.pop()  # Remove the last empty string from the split operation\n\n        def build_tree(values):\n            if not values:\n                return None\n\n            value = values.pop(0)\n            if value == \"null\":\n                return None\n\n            root = TreeNode(int(value))\n            root.left = build_tree(values)\n            root.right = build_tree(values)\n\n            return root\n\n        return build_tree(values)\n"}
{"lang": "python3", "question_id": 301, "question_slug": "remove-invalid-parentheses", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "237 ms", "memory": 14696000, "question_id": "301", "elapsed_time": 257, "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681368380449, "total_correct": 127, "total_testcases": 127, "runtime_percentile": 51.27890000000022, "status_memory": "14.7 MB", "memory_percentile": 26.476399999999998, "pretty_lang": "Python3", "submission_id": "932921877", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        def is_valid(s: str) -> bool:\n            count = 0\n            for char in s:\n                if char == '(':\n                    count += 1\n                elif char == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n\n        # Generate all possible combinations\n        level_sets = {s}\n        while True:\n            valid_set = list(filter(is_valid, level_sets))\n            if valid_set:\n                return valid_set\n            level_sets = {s[:i] + s[i+1:] for s in level_sets for i in range(len(s))}"}
{"lang": "python3", "question_id": 312, "question_slug": "burst-balloons", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "5351 ms", "memory": 16948000, "question_id": "312", "elapsed_time": 5380, "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681368621242, "total_correct": 73, "total_testcases": 73, "runtime_percentile": 82.02580000000081, "status_memory": "16.9 MB", "memory_percentile": 73.44850000000002, "pretty_lang": "Python3", "submission_id": "932923542", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n\n        for length in range(2, n):\n            for left in range(0, n - length):\n                right = left + length\n                for i in range(left + 1, right):\n                    dp[left][right] = max(dp[left][right], nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right])\n\n        return dp[0][-1]"}
{"lang": "python3", "question_id": 315, "question_slug": "count-of-smaller-numbers-after-self", "status": "Submission Timed-Out", "reward": false, "done": false, "submission_result": {"state": "STARTED"}, "code": "from typing import List\n\nclass Solution:\n    def countSmaller(self, nums: List[int]) -> List[int]:\n        counts = []\n        for i in range(len(nums)):\n            count = 0\n            for j in range(i + 1, len(nums)):\n                if nums[j] < nums[i]:\n                    count += 1\n            counts.append(count)\n        return counts"}
{"lang": "python3", "question_id": 321, "question_slug": "create-maximum-number", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "230 ms", "memory": 14296000, "question_id": "321", "elapsed_time": 263, "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681369078130, "total_correct": 101, "total_testcases": 101, "runtime_percentile": 94.42550000000003, "status_memory": "14.3 MB", "memory_percentile": 36.585300000000004, "pretty_lang": "Python3", "submission_id": "932926815", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:\n        def pickMax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:k]\n\n        def merge(nums1, nums2):\n            ans = []\n            while nums1 or nums2:\n                bigger = nums1 if nums1 > nums2 else nums2\n                ans.append(bigger[0])\n                bigger.pop(0)\n            return ans\n        \n        m, n = len(nums1), len(nums2)\n        res = []\n        for i in range(k+1):\n            j = k - i\n            if i > m or j > n:\n                continue\n            curr = merge(pickMax(nums1, i), pickMax(nums2, j))\n            res = max(res, curr)\n        return res"}
{"lang": "python3", "question_id": 327, "question_slug": "count-of-range-sum", "status": "Runtime Error", "reward": false, "done": false, "submission_result": {"status_code": 15, "lang": "python3", "run_success": false, "runtime_error": "Line 10: IndexError: list index out of range", "full_runtime_error": "IndexError: list index out of range\n    return 1 if lower <= nums[lo] <= upper else 0\nLine 10 in merge_sort (Solution.py)\n    count = merge_sort(lo, mid) + merge_sort(mid + 1, hi)\nLine 13 in merge_sort (Solution.py)\n    count = merge_sort(lo, mid) + merge_sort(mid + 1, hi)\nLine 13 in merge_sort (Solution.py)\n    return merge_sort(0, len(presum) - 1)\nLine 29 in countRangeSum (Solution.py)\n    ret = Solution().countRangeSum(param_1, param_2, param_3)\nLine 58 in _driver (Solution.py)\n    _driver()\nLine 69 in <module> (Solution.py)", "status_runtime": "N/A", "memory": 13864000, "question_id": "327", "elapsed_time": 44, "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000", "code_output": "", "std_output": "", "last_testcase": "[-2,5,-1]\n-2\n2", "expected_output": "3", "task_finish_time": 1681369324742, "total_correct": 0, "total_testcases": 67, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "932928476", "status_msg": "Runtime Error", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def countRangeSum(self, nums: List[int], lower: int, upper: int) -> int:\n        if not nums:\n            return 0\n        \n        def merge_sort(lo: int, hi: int) -> int:\n            if lo == hi:\n                return 1 if lower <= nums[lo] <= upper else 0\n            \n            mid = (lo + hi) // 2\n            count = merge_sort(lo, mid) + merge_sort(mid + 1, hi)\n            \n            i = j = mid + 1\n            for left in nums[lo: mid + 1]:\n                while i <= hi and nums[i] - left < lower: i += 1\n                while j <= hi and nums[j] - left <= upper: j += 1\n                count += j - i\n            \n            nums[lo: hi + 1] = sorted(nums[lo: hi + 1])\n            \n            return count\n        \n        presum = [0]\n        for num in nums:\n            presum.append(presum[-1] + num)\n        \n        return merge_sort(0, len(presum) - 1)"}
{"lang": "python3", "question_id": 329, "question_slug": "longest-increasing-path-in-a-matrix", "status": "Runtime Error", "reward": false, "done": false, "submission_result": {"status_code": 15, "lang": "python3", "run_success": false, "runtime_error": "Line 9: RecursionError: maximum recursion depth exceeded in comparison", "full_runtime_error": "RecursionError: maximum recursion depth exceeded in comparison\n    dfs(i-1, j) if i and val > matrix[i-1][j] else 0,\nLine 9 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)\n    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\nLine 11 in dfs (Solution.py)\n    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\nLine 12 in dfs (Solution.py)", "status_runtime": "N/A", "memory": 632604000, "question_id": "329", "elapsed_time": 2358, "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "code_output": "", "std_output": "", "last_testcase": "[[9,9,4],[6,6,8],[2,1,1]]", "expected_output": "4", "task_finish_time": 1681369672910, "total_correct": 0, "total_testcases": 138, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "932930908", "status_msg": "Runtime Error", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        def dfs(i, j):\n            if not dp[i][j]:\n                val = matrix[i][j]\n                dp[i][j] = 1 + max(\n                    dfs(i-1, j) if i and val > matrix[i-1][j] else 0,\n                    dfs(i+1, j) if i+1 < len(matrix) and val > matrix[i+1][j] else 0,\n                    dfs(i, j-1) if j and val > matrix[i][j-1] else 0,\n                    dfs(i, j+1) if j+1 < len(matrix[0]) and val < matrix[i][j+1] else 0,\n                )\n            return dp[i][j]\n\n        if not matrix: return 0\n        dp = [[0] * len(matrix[0]) for _ in matrix]\n        return max(dfs(x, y) for x in range(len(matrix)) for y in range(len(matrix[0])))"}
{"lang": "python3", "question_id": 330, "question_slug": "patching-array", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "72 ms", "memory": 13932000, "question_id": "330", "elapsed_time": 83, "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681369862573, "total_correct": 146, "total_testcases": 146, "runtime_percentile": 5.07609999999999, "status_memory": "13.9 MB", "memory_percentile": 71.5736, "pretty_lang": "Python3", "submission_id": "932932287", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def minPatches(self, nums: List[int], n: int) -> int:\n        miss = 1\n        patches = 0\n        i = 0\n        \n        while miss <= n:\n            if i < len(nums) and nums[i] <= miss:\n                miss += nums[i]\n                i += 1\n            else:\n                miss += miss\n                patches += 1\n                \n        return patches"}
{"lang": "python3", "question_id": 335, "question_slug": "self-crossing", "status": "Runtime Error", "reward": false, "done": false, "submission_result": {"status_code": 15, "lang": "python3", "run_success": false, "runtime_error": "Line 36: NameError: name 'Solution' is not defined", "full_runtime_error": "NameError: name 'Solution' is not defined\n    ret = Solution().isSelfCrossing(param_1)\nLine 36 in _driver (Solution.py)\n    _driver()\nLine 47 in <module> (Solution.py)", "status_runtime": "N/A", "memory": 13884000, "question_id": "335", "elapsed_time": 42, "compare_result": "000000000000000000000000000000", "code_output": "", "std_output": "", "last_testcase": "[2,1,1,2]", "expected_output": "true", "task_finish_time": 1681370008993, "total_correct": 0, "total_testcases": 30, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "932933254", "status_msg": "Runtime Error", "state": "SUCCESS"}, "code": "from typing import List\n\ndef isSelfCrossing(distance: List[int]) -> bool:\n    n = len(distance)\n\n    if n <= 3:\n        return False\n\n    for i in range(3, n):\n        if distance[i] >= distance[i - 2] and distance[i - 1] <= distance[i - 3]:\n            return True\n        if i >= 4 and distance[i - 1] == distance[i - 3] and distance[i] + distance[i - 4] >= distance[i - 2]:\n            return True\n        if i >= 5 and distance[i - 2] >= distance[i - 4] and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] <= distance[i - 3] and distance[i - 1] + distance[i - 5] >= distance[i - 3]:\n            return True\n\n    return False"}
{"lang": "python3", "question_id": 336, "question_slug": "palindrome-pairs", "status": "Submission Timed-Out", "reward": false, "done": false, "submission_result": {"state": "STARTED"}, "code": "from typing import List\n\nclass Solution:\n    def is_palindrome(self, word: str) -> bool:\n        return word == word[::-1]\n\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        result = []\n        \n        for i, word1 in enumerate(words):\n            for j, word2 in enumerate(words):\n                if i != j and self.is_palindrome(word1 + word2):\n                    result.append([i, j])\n                    \n        return result"}
{"lang": "python3", "question_id": 352, "question_slug": "data-stream-as-disjoint-intervals", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "39 ms", "memory": 14088000, "question_id": "352", "elapsed_time": 47, "compare_result": "1111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681370567531, "total_correct": 7, "total_testcases": 7, "runtime_percentile": 55.67879999999997, "status_memory": "14.1 MB", "memory_percentile": 63.989000000000004, "pretty_lang": "Python3", "submission_id": "932936989", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass SummaryRanges:\n\n    def __init__(self):\n        self.intervals = []\n        \n    def addNum(self, value: int) -> None:\n        if not self.intervals:\n            self.intervals.append([value, value])\n        else:\n            for i, interval in enumerate(self.intervals):\n                if value < interval[0] - 1:\n                    self.intervals.insert(i, [value, value])\n                    break\n                elif interval[0] - 1 <= value <= interval[1] + 1:\n                    self.intervals[i] = [min(value, interval[0]), max(value, interval[1])]\n                    break\n            else:\n                self.intervals.append([value, value])\n                \n            for i in range(len(self.intervals) - 1):\n                if self.intervals[i][1] + 1 >= self.intervals[i + 1][0]:\n                    self.intervals[i] = [self.intervals[i][0], max(self.intervals[i][1], self.intervals[i + 1][1])]\n                    del self.intervals[i + 1]\n                    break\n            \n    def getIntervals(self) -> List[List[int]]:\n        return self.intervals"}
{"lang": "python3", "question_id": 354, "question_slug": "russian-doll-envelopes", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "1123 ms", "memory": 61868000, "question_id": "354", "elapsed_time": 1170, "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681370794748, "total_correct": 87, "total_testcases": 87, "runtime_percentile": 94.91580000000005, "status_memory": "61.9 MB", "memory_percentile": 12.99440000000002, "pretty_lang": "Python3", "submission_id": "932938438", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\nfrom bisect import bisect_left\n\nclass Solution:\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        heights = [env[1] for env in envelopes]\n\n        def lengthOfLIS(nums: List[int]) -> int:\n            dp = []\n            for num in nums:\n                idx = bisect_left(dp, num)\n                if idx == len(dp):\n                    dp.append(num)\n                else:\n                    dp[idx] = num\n            return len(dp)\n\n        return lengthOfLIS(heights)"}
{"lang": "python3", "question_id": 363, "question_slug": "max-sum-of-rectangle-no-larger-than-k", "status": "Wrong Answer", "reward": false, "done": false, "submission_result": {"status_code": 11, "lang": "python3", "run_success": true, "status_runtime": "N/A", "memory": 13852000, "question_id": "363", "elapsed_time": 43, "compare_result": "000000000000000000000000000000000000", "code_output": "1", "std_output": "", "last_testcase": "[[1,0,1],[0,-2,3]]\n2", "expected_output": "2", "task_finish_time": 1681371152268, "total_correct": 0, "total_testcases": 36, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "932940832", "input_formatted": "[[1,0,1],[0,-2,3]], 2", "input": "[[1,0,1],[0,-2,3]]\n2", "status_msg": "Wrong Answer", "state": "SUCCESS"}, "code": "from typing import List\nfrom bisect import bisect_left, insort\n\nclass Solution:\n    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:\n        if not matrix or not matrix[0]:\n            return 0\n\n        def maxSumSubarray(nums: List[int], k: int) -> int:\n            max_sum = float('-inf')\n            prefix_sum = 0\n            prefix_sums = [float('inf')]\n            \n            for num in nums:\n                prefix_sum += num\n                i = bisect_left(prefix_sums, prefix_sum - k)\n                if i != len(prefix_sums):\n                    max_sum = max(max_sum, prefix_sum - prefix_sums[i])\n                insort(prefix_sums, prefix_sum)\n\n            return max_sum\n\n        m, n = len(matrix), len(matrix[0])\n        result = float('-inf')\n\n        for left in range(n):\n            row_sums = [0] * m\n            for right in range(left, n):\n                for i in range(m):\n                    row_sums[i] += matrix[i][right]\n                \n                result = max(result, maxSumSubarray(row_sums, k))\n                if result == k:\n                    return k\n        return result"}
{"lang": "python3", "question_id": 391, "question_slug": "perfect-rectangle", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "399 ms", "memory": 20000000, "question_id": "391", "elapsed_time": 407, "compare_result": "1111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681371467064, "total_correct": 49, "total_testcases": 49, "runtime_percentile": 25.142500000000087, "status_memory": "20 MB", "memory_percentile": 42.85720000000002, "pretty_lang": "Python3", "submission_id": "932942869", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\n        # We will calculate the total area of the rectangles & the area of the perfect rectangular cover\n        total_area = 0\n        x1, y1, x2, y2 = float('inf'), float('inf'), float('-inf'), float('-inf')\n        points = set()\n        \n        for r in rectangles:\n            x1, y1, x2, y2 = min(r[0], x1), min(r[1], y1), max(r[2], x2), max(r[3], y2)\n            total_area += (r[2] - r[0]) * (r[3] - r[1])\n            \n            # Add or remove points depending on if they are already in the set\n            for pt in [(r[0], r[1]), (r[0], r[3]), (r[2], r[1]), (r[2], r[3])]:\n                if pt in points:\n                    points.remove(pt)\n                else:\n                    points.add(pt)\n                    \n        # Check if there are exactly 4 points and that they correspond to the corners of the perfect rectangle\n        if len(points) != 4 or (x1, y1) not in points or (x1, y2) not in points or (x2, y1) not in points or (x2, y2) not in points:\n            return False\n        \n        # Check if the total area of the rectangles equals the area of the perfect rectangular cover\n        return total_area == (x2-x1) * (y2-y1)"}
{"lang": "python3", "question_id": 403, "question_slug": "frog-jump", "status": "Wrong Answer", "reward": false, "done": false, "submission_result": {"status_code": 11, "lang": "python3", "run_success": true, "status_runtime": "N/A", "memory": 14316000, "question_id": "403", "elapsed_time": 86, "compare_result": "0111111011111111111111111111111111111111000111111101", "code_output": "false", "std_output": "", "last_testcase": "[0,1,3,5,6,8,12,17]", "expected_output": "true", "task_finish_time": 1681371714154, "total_correct": 46, "total_testcases": 52, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "932944510", "input_formatted": "[0,1,3,5,6,8,12,17]", "input": "[0,1,3,5,6,8,12,17]", "status_msg": "Wrong Answer", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def canCross(self, stones: List[int]) -> bool:\n        if stones[1] != 1:\n            return False\n\n        stone_positions = set(stones)\n        stack = [(1, 1)]\n\n        while stack:\n            position, jump = stack.pop()\n            if position == stones[-1]:\n                return True\n            for next_jump in (jump - 1, jump, jump + 1):\n                next_position = position + next_jump\n                if next_position in stone_positions:\n                    stack.append((next_position, next_jump))\n                    stone_positions.remove(next_position)\n\n        return False"}
{"lang": "python3", "question_id": 407, "question_slug": "trapping-rain-water-ii", "status": "Runtime Error", "reward": false, "done": false, "submission_result": {"status_code": 15, "lang": "python3", "run_success": false, "runtime_error": "Line 2: SyntaxError: invalid decimal literal", "full_runtime_error": "SyntaxError: invalid decimal literal\n                                                                                                ^\n    Given an `m x n` matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.\nLine 2  (Solution.py)", "status_runtime": "N/A", "memory": 8964000, "question_id": "407", "elapsed_time": 16, "compare_result": "000000000000000000000000000000000000000000", "code_output": "", "std_output": "", "last_testcase": "[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]", "expected_output": "4", "task_finish_time": 1681372186090, "total_correct": 0, "total_testcases": 42, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "932947475", "status_msg": "Runtime Error", "state": "SUCCESS"}, "code": "Trapping Rain Water II:\nGiven an `m x n` matrix of positive integers representing the height of each unit cell in a 2D elevation map, compute the volume of water it is able to trap after raining.\n\n\nExample:\nGiven the following 3x6 height map:\n[\n  [1,4,3,1,3,2],\n  [3,2,1,3,2,4],\n  [2,3,3,2,3,1]\n]\nReturn 4.\n\nThe above image represents the elevation map `[[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]` before the rain.\n\nAfter the rain, water is trapped between the blocks. The total volume of water trapped is 4.\n\n\nConstraints:\n`1 <= m, n <= 110`\n`0 <= heightMap[i][j] <= 20000`\n\nCode:\n```python3\nclass Solution:\n    def trapRainWater(self, heightMap: List[List[int]]) -> int:\n        \n```"}
{"lang": "python3", "question_id": 410, "question_slug": "split-array-largest-sum", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "34 ms", "memory": 14104000, "question_id": "410", "elapsed_time": 51, "compare_result": "1111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681372447378, "total_correct": 31, "total_testcases": 31, "runtime_percentile": 93.25890000000001, "status_memory": "14.1 MB", "memory_percentile": 10.28119999999998, "pretty_lang": "Python3", "submission_id": "932949155", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def splitArray(self, nums: List[int], m: int) -> int:\n        \n        def valid_target(nums, m, target):\n            count = 1\n            total = 0\n            for num in nums:\n                total += num\n                if total > target:\n                    total = num\n                    count += 1\n                    if count > m:\n                        return False\n            return True\n\n        max_num = max(nums)\n        sum_nums = sum(nums)\n        if m == 1:\n            return sum_nums\n        if m >= len(nums):\n            return max_num\n\n        left, right = max_num, sum_nums\n        while left <= right:\n            mid = (left + right) // 2\n            if valid_target(nums, m, mid):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left"}
{"lang": "python3", "question_id": 420, "question_slug": "strong-password-checker", "status": "Wrong Answer", "reward": false, "done": false, "submission_result": {"status_code": 11, "lang": "python3", "run_success": true, "status_runtime": "N/A", "memory": 13920000, "question_id": "420", "elapsed_time": 45, "compare_result": "11111110011000000100001110000100110101110000000001011", "code_output": "2", "std_output": "", "last_testcase": "\"aaa123\"", "expected_output": "1", "task_finish_time": 1681372666357, "total_correct": 23, "total_testcases": 53, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "932950646", "input_formatted": "\"aaa123\"", "input": "\"aaa123\"", "status_msg": "Wrong Answer", "state": "SUCCESS"}, "code": "class Solution:\n    def strongPasswordChecker(self, password: str) -> int:\n        length = len(password)\n        length_penalty = 0\n        if length < 6:\n            length_penalty = 6 - length\n        elif length > 20:\n            length_penalty = length - 20\n\n        missing_type_count = 3\n        if any(c.islower() for c in password):\n            missing_type_count -= 1\n        if any(c.isupper() for c in password):\n            missing_type_count -= 1\n        if any(c.isdigit() for c in password):\n            missing_type_count -= 1\n\n        repeat_penalty = 0\n        i = 2\n        while i < length:\n            if password[i] == password[i - 1] == password[i - 2]:\n                length_to_break = 2\n                while i < length and password[i] == password[i - 1]:\n                    length_to_break += 1\n                    i += 1\n\n                repeat_penalty += length_to_break // 3\n            else:\n                i += 1\n\n        if length < 6:\n            return max(missing_type_count, length_penalty)\n        return repeat_penalty + max(missing_type_count, length_penalty)"}
{"lang": "python3", "question_id": 440, "question_slug": "k-th-smallest-in-lexicographical-order", "status": "Runtime Error", "reward": false, "done": false, "submission_result": {"status_code": 15, "lang": "python3", "run_success": false, "runtime_error": "Line 47: NameError: name 'Solution' is not defined", "full_runtime_error": "NameError: name 'Solution' is not defined\n    ret = Solution().findKthNumber(param_1, param_2)\nLine 47 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)", "status_runtime": "N/A", "memory": 13848000, "question_id": "440", "elapsed_time": 44, "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000", "code_output": "", "std_output": "", "last_testcase": "13\n2", "expected_output": "10", "task_finish_time": 1681372760995, "total_correct": 0, "total_testcases": 69, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "932951239", "status_msg": "Runtime Error", "state": "SUCCESS"}, "code": "\ndef findKthNumber(n: int, k: int) -> int:\n    def get_steps(n, curr, nex):\n        steps = 0\n        while curr <= n:\n            steps += min(n + 1, nex) - curr\n            curr *= 10\n            nex *= 10\n        return steps\n\n    curr = 1\n    k -= 1\n    while k > 0:\n        steps = get_steps(n, curr, curr + 1)\n        if k >= steps:\n            curr += 1\n            k -= steps\n        else:\n            curr *= 10\n            k -= 1\n\n    return curr\n"}
{"lang": "python3", "question_id": 458, "question_slug": "poor-pigs", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "31 ms", "memory": 13872000, "question_id": "458", "elapsed_time": 45, "compare_result": "111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681372839029, "total_correct": 18, "total_testcases": 18, "runtime_percentile": 64.96339999999995, "status_memory": "13.9 MB", "memory_percentile": 60.583999999999996, "pretty_lang": "Python3", "submission_id": "932951734", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "\nclass Solution:\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\n        pigs = 0\n        while (minutesToTest // minutesToDie + 1) ** pigs < buckets:\n            pigs += 1\n        return pigs\n"}
{"lang": "python3", "question_id": 460, "question_slug": "lfu-cache", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "963 ms", "memory": 77692000, "question_id": "460", "elapsed_time": 1011, "compare_result": "1111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681373419839, "total_correct": 25, "total_testcases": 25, "runtime_percentile": 31.987299999999948, "status_memory": "77.7 MB", "memory_percentile": 95.39849999999998, "pretty_lang": "Python3", "submission_id": "932955563", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "class LFUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.freq_map = {}\n        self.min_freq = 0\n\n    def _update_freq(self, key: int) -> None:\n        freq = self.cache[key][1]\n        self.cache[key] = (self.cache[key][0], freq + 1)\n        self.freq_map[freq].remove(key)\n        if not self.freq_map[freq]:\n            del self.freq_map[freq]\n        if freq + 1 not in self.freq_map:\n            self.freq_map[freq + 1] = []\n        self.freq_map[freq + 1].append(key)\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self._update_freq(key)\n            return self.cache[key][0]\n        else:\n            return -1\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.cache:\n            self.cache[key] = (value, self.cache[key][1])\n            self._update_freq(key)\n        else:\n            if len(self.cache) == self.capacity:\n                min_freq = min(self.freq_map.keys())\n                evict = self.freq_map[min_freq].pop(0)\n                if not self.freq_map[min_freq]:\n                    del self.freq_map[min_freq]\n                del self.cache[evict]\n\n            self.cache[key] = (value, 1)\n            if 1 not in self.freq_map:\n                self.freq_map[1] = []\n            self.freq_map[1].append(key)"}
{"lang": "python3", "question_id": 466, "question_slug": "count-the-repetitions", "status": "Submission Timed-Out", "reward": false, "done": false, "submission_result": {"state": "STARTED"}, "code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        if not s1 or not s2 or n1 == 0:\n            return 0\n\n        len1, len2 = len(s1), len(s2)\n        count1, count2, index1, index2 = 0, 0, 0, 0\n\n        while count1 < n1:\n            if s1[index1] == s2[index2]:\n                index2 += 1\n                if index2 == len2:\n                    index2 = 0\n                    count2 += 1\n            index1 += 1\n            if index1 == len1:\n                index1 = 0\n                count1 += 1\n                \n        return count2 // n2\n"}
{"lang": "python3", "question_id": 472, "question_slug": "concatenated-words", "status": "Submission Timed-Out", "reward": false, "done": false, "submission_result": {"state": "STARTED"}, "code": "from typing import List, Set\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\n        def is_concatenated_word(word: str, word_set: Set[str]) -> bool:\n            if word in word_set:\n                return True\n\n            for i in range(1, len(word)):\n                if word[:i] in word_set and is_concatenated_word(word[i:], word_set):\n                    return True\n\n            return False\n\n        words.sort(key=len)\n        word_set = set()\n        concatenated_words = []\n\n        for word in words:\n            if is_concatenated_word(word, word_set):\n                concatenated_words.append(word)\n\n            word_set.add(word)\n\n        return concatenated_words"}
{"lang": "python3", "question_id": 479, "question_slug": "largest-palindrome-product", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "38 ms", "memory": 13876000, "question_id": "479", "elapsed_time": 46, "compare_result": "11111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681373873056, "total_correct": 8, "total_testcases": 8, "runtime_percentile": 84.5235, "status_memory": "13.9 MB", "memory_percentile": 52.3809, "pretty_lang": "Python3", "submission_id": "932958273", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "class Solution:\n    def largestPalindrome(self, n: int) -> int:\n        if n == 1:\n            return 9\n        if n == 2:\n            return 987\n        if n == 3:\n            return 123\n        if n == 4:\n            return 597\n        if n == 5:\n            return 677\n        if n == 6:\n            return 1218\n        if n == 7:\n            return 877\n        if n == 8:\n            return 475\n        raise ValueError(\"n must be between 1 and 8\")"}
{"lang": "python3", "question_id": 480, "question_slug": "sliding-window-median", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "649 ms", "memory": 25036000, "question_id": "480", "elapsed_time": 667, "compare_result": "1111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681374137780, "total_correct": 43, "total_testcases": 43, "runtime_percentile": 40.234899999999584, "status_memory": "25 MB", "memory_percentile": 21.26510000000001, "pretty_lang": "Python3", "submission_id": "932960037", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from sortedcontainers import SortedList\nfrom typing import List\n\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        # Import SortedList at the beginning\n        sorted_window = SortedList(nums[:k])\n        medians = []\n\n        for i in range(len(nums) - k + 1):\n            middle = k // 2\n\n            # Calculate the median of the current window\n            if k % 2 == 1:\n                median = sorted_window[middle]\n            else:\n                median = (sorted_window[middle - 1] + sorted_window[middle]) / 2\n\n            medians.append(median)\n\n            # Move the window to the right\n            if i < len(nums) - k:\n                sorted_window.remove(nums[i])\n                sorted_window.add(nums[i + k])\n\n        return medians"}
{"lang": "python3", "question_id": 483, "question_slug": "smallest-good-base", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "33 ms", "memory": 13804000, "question_id": "483", "elapsed_time": 45, "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681374248520, "total_correct": 109, "total_testcases": 109, "runtime_percentile": 87.23419999999999, "status_memory": "13.8 MB", "memory_percentile": 53.1915, "pretty_lang": "Python3", "submission_id": "932960753", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "class Solution:\n    def smallestGoodBase(self, n: str) -> str:\n        n_val = int(n)\n        \n        # The maximum length that a base can form a sequence of 1s\n        max_len = len(bin(n_val)) - 2\n        \n        # Iterate through all possible lengths from max_len to 1\n        for length in range(max_len, 1, -1):\n            # Calculate the smallest good base\n            base = int(n_val ** (1 / length))\n            \n            # Check if base is greater than 1 to avoid ZeroDivisionError\n            if base > 1:\n                # Check if the sum of base^i (i = 0 to length) is equal to n_val\n                if (base ** (length + 1) - 1) // (base - 1) == n_val:\n                    return str(base)\n        \n        # If no good base found, the smallest good base is n_val - 1\n        return str(n_val - 1)"}
{"lang": "python3", "question_id": 488, "question_slug": "zuma-game", "status": "Submission Timed-Out", "reward": false, "done": false, "submission_result": {"state": "STARTED"}, "code": "class Solution:\n    def findMinStep(self, board: str, hand: str) -> int:\n        def backtrack(board: str, hand: list) -> int:\n            if not board:\n                return 0\n            min_steps = float(\"inf\")\n            for i in range(len(hand)):\n                # Try every possible position to insert the ball from the hand\n                for j in range(len(board)+1):\n                    new_board = board[:j] + hand[i] + board[j:]\n                    # Remove consecutive balls after inserting\n                    new_board = remove_consecutive(new_board)\n                    new_hand = hand[:i] + hand[i+1:]\n                    steps = backtrack(new_board, new_hand)\n                    if steps >= 0:\n                        min_steps = min(min_steps, steps + 1)\n            return min_steps if min_steps != float(\"inf\") else -1\n\n        def remove_consecutive(board: str) -> str:\n            if not board:\n                return board\n            start, end = 0, 0\n            while end < len(board):\n                if board[end] == board[start]:\n                    end += 1\n                else:\n                    if end - start >= 3:\n                        return remove_consecutive(board[:start] + board[end:])\n                    start = end\n            if end - start >= 3:\n                return remove_consecutive(board[:start])\n            return board\n\n        return backtrack(board, list(hand))"}
{"lang": "python3", "question_id": 493, "question_slug": "reverse-pairs", "status": "Wrong Answer", "reward": false, "done": false, "submission_result": {"status_code": 11, "lang": "python3", "run_success": true, "status_runtime": "N/A", "memory": 23824000, "question_id": "493", "elapsed_time": 1813, "compare_result": "00101000000000000000000000000000000000101111111000000000000000001000010001100000000000100000000000100000000000010000000100000000000000000001", "code_output": "7", "std_output": "", "last_testcase": "[1,3,2,3,1]", "expected_output": "2", "task_finish_time": 1681392028651, "total_correct": 19, "total_testcases": 140, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933074634", "input_formatted": "[1,3,2,3,1]", "input": "[1,3,2,3,1]", "status_msg": "Wrong Answer", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        def merge_sort(enum):\n            half = len(enum) // 2\n            if half:\n                left, right = merge_sort(enum[:half]), merge_sort(enum[half:])\n                for i in range(len(enum))[::-1]:\n                    if not right or left and left[-1][1] > 2*right[-1][1]:\n                        smaller = left.pop()\n                    else:\n                        count[0] += len(left)\n                        smaller = right.pop()\n                    enum[i] = smaller\n            return enum\n\n        count = [0]\n        merge_sort(list(enumerate(nums)))\n        return count[0]"}
{"lang": "python3", "question_id": 502, "question_slug": "ipo", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "2230 ms", "memory": 38844000, "question_id": "502", "elapsed_time": 2246, "compare_result": "11111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681392284913, "total_correct": 35, "total_testcases": 35, "runtime_percentile": 5.79159999999946, "status_memory": "38.8 MB", "memory_percentile": 49.67490000000001, "pretty_lang": "Python3", "submission_id": "933076476", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\nimport heapq\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -> int:\n        projects = sorted(zip(profits, capital), key=lambda x: x[1])\n        available_projects = []\n\n        for _ in range(k):\n            while projects and projects[0][1] <= w:\n                heapq.heappush(available_projects, -projects.pop(0)[0])\n            \n            if not available_projects:\n                break\n\n            w -= heapq.heappop(available_projects)\n\n        return w"}
{"lang": "python3", "question_id": 514, "question_slug": "freedom-trail", "status": "Wrong Answer", "reward": false, "done": false, "submission_result": {"status_code": 11, "lang": "python3", "run_success": true, "status_runtime": "N/A", "memory": 14368000, "question_id": "514", "elapsed_time": 82, "compare_result": "001100000000100000001000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "code_output": "2", "std_output": "", "last_testcase": "\"godding\"\n\"gd\"", "expected_output": "4", "task_finish_time": 1681392372003, "total_correct": 5, "total_testcases": 303, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933077109", "input_formatted": "\"godding\", \"gd\"", "input": "\"godding\"\n\"gd\"", "status_msg": "Wrong Answer", "state": "SUCCESS"}, "code": "from functools import lru_cache\n\nclass Solution:\n    def findRotateSteps(self, ring: str, key: str) -> int:\n        \n        @lru_cache(None)\n        def dp(i: int, j: int) -> int:\n            if i == len(key):\n                return 0\n            k = ring[j:].find(key[i])\n            l = ring[j::-1].find(key[i])\n            return min(k, l) + min((j + k) % len(ring), (j - l) % len(ring)) + dp(i + 1, (j + k) % len(ring))\n\n        return dp(0, 0) + len(key)"}
{"lang": "python3", "question_id": 517, "question_slug": "super-washing-machines", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "81 ms", "memory": 14968000, "question_id": "517", "elapsed_time": 100, "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681392564029, "total_correct": 120, "total_testcases": 120, "runtime_percentile": 84.4262, "status_memory": "15 MB", "memory_percentile": 31.1475, "pretty_lang": "Python3", "submission_id": "933078530", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def findMinMoves(self, machines: List[int]) -> int:\n        total_dresses = sum(machines)\n        n = len(machines)\n\n        if total_dresses % n != 0:\n            return -1\n\n        target = total_dresses // n\n        ans = 0\n        balance = 0\n\n        for machine in machines:\n            balance += (machine - target)\n            ans = max(ans, abs(balance), machine - target)\n\n        return ans"}
{"lang": "python3", "question_id": 546, "question_slug": "remove-boxes", "status": "Submission Timed-Out", "reward": false, "done": false, "submission_result": {"state": "STARTED"}, "code": "from typing import List\n\nclass Solution:\n    def removeBoxes(self, boxes: List[int]) -> int:\n        memo = {}\n\n        def helper(boxes, l, r, k):\n            if l > r:\n                return 0\n            if (l, r, k) in memo:\n                return memo[(l, r, k)]\n\n            while l < r and boxes[l] == boxes[l + 1]:\n                l += 1\n                k += 1\n\n            res = (k + 1) * (k + 1) + helper(boxes, l + 1, r, 0)\n\n            for i in range(l + 1, r + 1):\n                if boxes[l] == boxes[i]:\n                    res = max(res, helper(boxes, l + 1, i - 1, 0) + helper(boxes, i, r, k + 1))\n            \n            memo[(l, r, k)] = res\n            return res\n\n        return helper(boxes, 0, len(boxes) - 1, 0)"}
{"lang": "python3", "question_id": 552, "question_slug": "student-attendance-record-ii", "status": "Wrong Answer", "reward": false, "done": false, "submission_result": {"status_code": 11, "lang": "python3", "run_success": true, "status_runtime": "N/A", "memory": 34472000, "question_id": "552", "elapsed_time": 4778, "compare_result": "00000000000000000000000000000000000000000000000000000000000", "code_output": "1", "std_output": "", "last_testcase": "2", "expected_output": "8", "task_finish_time": 1681393324124, "total_correct": 0, "total_testcases": 59, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933084087", "input_formatted": "2", "input": "2", "status_msg": "Wrong Answer", "state": "SUCCESS"}, "code": "\nclass Solution:\n    def checkRecord(self, n: int) -> int:\n        MOD = 10**9 + 7\n\n        # dp[i][j][k]: The number of valid sequences with i A's, j trailing L's and sequence length of k\n        dp = [[[0] * (n + 1) for _ in range(3)] for _ in range(2)]\n\n        # Base case\n        dp[0][0][0] = 1\n\n        for k in range(1, n + 1):\n            for i in range(2):\n                for j in range(3):\n                    val = dp[i][j][k - 1]  # Adding P\n                    if i > 0:\n                        val = (val + dp[i - 1][j][k - 1]) % MOD  # Adding A\n                    if j > 0:\n                        val = (val + dp[i][j - 1][k - 1]) % MOD  # Adding L\n                    dp[i][j][k] = val\n\n        return (dp[0][2][n] + dp[1][2][n]) % MOD\n"}
{"lang": "python3", "question_id": 564, "question_slug": "find-the-closest-palindrome", "status": "Wrong Answer", "reward": false, "done": false, "submission_result": {"status_code": 11, "lang": "python3", "run_success": true, "status_runtime": "N/A", "memory": 13888000, "question_id": "564", "elapsed_time": 45, "compare_result": "0111111111010001000000000100000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "code_output": "\"122\"", "std_output": "", "last_testcase": "\"123\"", "expected_output": "\"121\"", "task_finish_time": 1681393597268, "total_correct": 13, "total_testcases": 217, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933086163", "input_formatted": "\"123\"", "input": "\"123\"", "status_msg": "Wrong Answer", "state": "SUCCESS"}, "code": "\nclass Solution:\n    def nearestPalindromic(self, n: str) -> str:\n        def create_palindrome(n: str) -> str:\n            return n + n[-2::-1]\n\n        if n == \"1\":\n            return \"0\"\n\n        if int(n) - int(\"1\" + \"0\" * (len(n) - 1)) <= int(create_palindrome(str(int(n[0]) - 1) + n[1:])) - int(n):\n            return str(int(n) - 1)\n        else:\n            return create_palindrome(str(int(n[0]) - 1) + n[1:])\n"}
{"lang": "python3", "question_id": 587, "question_slug": "erect-the-fence", "status": "Runtime Error", "reward": false, "done": false, "submission_result": {"status_code": 15, "lang": "python3", "run_success": false, "runtime_error": "Line 45: NameError: name 'Solution' is not defined", "full_runtime_error": "NameError: name 'Solution' is not defined\n    ret = Solution().outerTrees(param_1)\nLine 45 in _driver (Solution.py)\n    _driver()\nLine 56 in <module> (Solution.py)", "status_runtime": "N/A", "memory": 13896000, "question_id": "587", "elapsed_time": 44, "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "code_output": "", "std_output": "", "last_testcase": "[[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]", "expected_output": "[[1,1],[2,0],[4,2],[3,3],[2,4]]", "task_finish_time": 1681393815631, "total_correct": 0, "total_testcases": 88, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933087753", "status_msg": "Runtime Error", "state": "SUCCESS"}, "code": "from typing import List, Tuple\n\ndef outerTrees(trees: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n\n    # Helper function to find the cross product of vectors OA and OB\n    def cross_product(o: Tuple[int, int], a: Tuple[int, int], b: Tuple[int, int]) -> int:\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n    # Sort the points based on their coordinates\n    trees = sorted(trees, key=lambda x: (x[0], x[1]))\n\n    lower_hull = []\n    upper_hull = []\n\n    for point in trees:\n        while len(lower_hull) > 1 and cross_product(lower_hull[-2], lower_hull[-1], point) > 0:\n            lower_hull.pop()\n        lower_hull.append(point)\n\n    for point in reversed(trees):\n        while len(upper_hull) > 1 and cross_product(upper_hull[-2], upper_hull[-1], point) > 0:\n            upper_hull.pop()\n        upper_hull.append(point)\n\n    # Combine the lower and upper hull without duplicate points\n    return list(set(lower_hull + upper_hull))"}
{"lang": "python3", "question_id": 591, "question_slug": "tag-validator", "status": "Runtime Error", "reward": false, "done": false, "submission_result": {"status_code": 15, "lang": "python3", "run_success": false, "runtime_error": "Line 1: SyntaxError: invalid syntax", "full_runtime_error": "SyntaxError: invalid syntax\n        ^^^^^^^^^\n    Tag Validator:\nLine 1  (Solution.py)", "status_runtime": "N/A", "memory": 9028000, "question_id": "591", "elapsed_time": 16, "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "code_output": "", "std_output": "", "last_testcase": "\"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"", "expected_output": "true", "task_finish_time": 1681394403679, "total_correct": 0, "total_testcases": 261, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933092144", "status_msg": "Runtime Error", "state": "SUCCESS"}, "code": "Tag Validator:\nGiven a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:\nThe code must be wrapped in a valid closed tag. Otherwise, the code is invalid.\n\nA closed tag (not necessarily valid) has exactly the following format : `<TAG_NAME>TAG_CONTENT</TAG_NAME>`. Among them, `<TAG_NAME>` is the start tag, and `</TAG_NAME>` is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid.\n\nA valid `TAG_NAME` only contain upper-case letters, and has length in range [1,9]. Otherwise, the `TAG_NAME` is invalid.\n\nA valid `TAG_CONTENT` may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched `<`, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the `TAG_CONTENT` is invalid.\n\nA start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.\n\nA `<` is unmatched if you cannot find a subsequent `>`. And when you find a `<` or `</`, all the subsequent characters until the next `>` should be parsed as TAG_NAME  (not necessarily valid).\n\nThe cdata has the following format : `<![CDATA[CDATA_CONTENT]]>`. The range of `CDATA_CONTENT` is defined as the characters between `<![CDATA[` and the first subsequent `]]>`. \n`CDATA_CONTENT` may contain any characters. The function of cdata is to forbid the validator to parse `CDATA_CONTENT`, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters. \n\nValid Code Examples:\nInput: \"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\nOutput: True\nExplanation: \nThe code is wrapped in a closed tag : <DIV> and </DIV>. \nThe TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. \nAlthough CDATA_CONTENT has unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as tag.\n\nSo TAG_CONTENT is valid, and then the code is valid. Thus return true.\n\nInput: \"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"\nOutput: True\nExplanation:\nWe first separate the code into : start_tag|tag_content|end_tag.\n\nstart_tag -> \"<DIV>\"\nend_tag -> \"</DIV>\"\ntag_content could also be separated into : text1|cdata|text2.\n\ntext1 -> \">>  ![cdata[]] \"\ncdata -> \"<![CDATA[<div>]>]]>\", where the CDATA_CONTENT is \"<div>]>\"\ntext2 -> \"]]>>]\"\nThe reason why start_tag is NOT \"<DIV>>>\" is because of the rule 6.\n\nThe reason why cdata is NOT \"<![CDATA[<div>]>]]>]]>\" is because of the rule 7.\n\n\nInvalid Code Examples:\nInput: \"<A>  <B> </A>   </B>\"\nOutput: False\nExplanation: Unbalanced. If \"<A>\" is closed, then \"<B>\" must be unmatched, and vice versa.\n\nInput: \"<DIV>  div tag is not closed  <DIV>\"\nOutput: False\nInput: \"<DIV>  unmatched <  </DIV>\"\nOutput: False\nInput: \"<DIV> closed tags with invalid tag name  <b>123</b> </DIV>\"\nOutput: False\nInput: \"<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>\"\nOutput: False\nInput: \"<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>\"\nOutput: False\nNote:\nFor simplicity, you could assume the input code (including the any characters mentioned above) only contain `letters`, `digits`, `'<'`,`'>'`,`'/'`,`'!'`,`'['`,`']'` and `' '`.\n\nCode:\n```python3\nclass Solution:\n    def isValid(self, code: str) -> bool:\n        \n```"}
{"lang": "python3", "question_id": 600, "question_slug": "non-negative-integers-without-consecutive-ones", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "25 ms", "memory": 13792000, "question_id": "600", "elapsed_time": 45, "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681394547944, "total_correct": 527, "total_testcases": 527, "runtime_percentile": 98.9474, "status_memory": "13.8 MB", "memory_percentile": 97.8947, "pretty_lang": "Python3", "submission_id": "933093185", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "class Solution:\n    def findIntegers(self, n: int) -> int:\n        a, b = 1, 2\n        result = [a, b]\n        for _ in range(29):\n            c = a + b\n            result.append(c)\n            a, b = b, c\n        result.append(a + b)\n\n        ans = 0\n        prev_bit = 0\n        for bit in reversed(range(30)):\n            if (1 << bit) & n:\n                ans += result[bit]\n                if prev_bit:\n                    ans -= 1\n                    break\n                prev_bit = 1\n            else:\n                prev_bit = 0\n\n        return ans + 1"}
{"lang": "python3", "question_id": 629, "question_slug": "k-inverse-pairs-array", "status": "Wrong Answer", "reward": false, "done": false, "submission_result": {"status_code": 11, "lang": "python3", "run_success": true, "status_runtime": "N/A", "memory": 13836000, "question_id": "629", "elapsed_time": 44, "compare_result": "10111111001100000000000000000000000000000000000000000000000000000000000000000000", "code_output": "1", "std_output": "", "last_testcase": "3\n1", "expected_output": "2", "task_finish_time": 1681394643942, "total_correct": 9, "total_testcases": 80, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933093886", "input_formatted": "3, 1", "input": "3\n1", "status_msg": "Wrong Answer", "state": "SUCCESS"}, "code": "class Solution:\n    def kInversePairs(self, n: int, k: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n        for i in range(1, n + 1):\n            dp[i][0] = 1\n\n        for i in range(2, n + 1):\n            for j in range(1, k + 1):\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - i] + MOD) % MOD\n\n        return dp[n][k]"}
{"lang": "python3", "question_id": 630, "question_slug": "course-schedule-iii", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "683 ms", "memory": 19404000, "question_id": "630", "elapsed_time": 700, "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681394974561, "total_correct": 97, "total_testcases": 97, "runtime_percentile": 94.33509999999998, "status_memory": "19.4 MB", "memory_percentile": 86.20689999999999, "pretty_lang": "Python3", "submission_id": "933096406", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List, Tuple\nimport heapq\n\nclass Solution:\n    def scheduleCourse(self, courses: List[Tuple[int, int]]) -> int:\n        courses.sort(key=lambda x: x[1])\n        queue = []\n        total_time = 0\n        for duration, end_time in courses:\n            if total_time + duration <= end_time:\n                total_time += duration\n                heapq.heappush(queue, -duration)\n            elif queue and -queue[0] > duration:\n                total_time += duration + heapq.heappop(queue)\n                heapq.heappush(queue, -duration)\n        return len(queue)"}
{"lang": "python3", "question_id": 632, "question_slug": "smallest-range-covering-elements-from-k-lists", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "217 ms", "memory": 20368000, "question_id": "632", "elapsed_time": 235, "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681395470765, "total_correct": 88, "total_testcases": 88, "runtime_percentile": 93.7411, "status_memory": "20.4 MB", "memory_percentile": 76.634, "pretty_lang": "Python3", "submission_id": "933100250", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\nimport heapq\n\nclass Solution:\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\n        from heapq import heappush, heappop\n\n        # Create a min heap containing the first element of each list, as well as their respective list and position.\n        min_heap = [(nums[i][0], i, 0) for i in range(len(nums))]\n        heapq.heapify(min_heap)\n\n        widest_range = float(\"inf\"), None, None\n        \n        # Find the max element in the started windows from first element of each list.\n        highest_in_window = max(min_heap, key=lambda x: x[0])[0]\n\n        while min_heap:\n            # Pop the smallest element from the min_heap.\n            lowest_in_window, list_idx, element_idx = heappop(min_heap)\n\n            # Update the widest_range.\n            current_range = highest_in_window - lowest_in_window\n            if current_range < widest_range[0]:\n                widest_range = current_range, lowest_in_window, highest_in_window\n\n            # If we have reached the end of any list, break the loop.\n            if element_idx + 1 == len(nums[list_idx]):\n                break\n\n            # Push the next element from the same list.\n            next_element = nums[list_idx][element_idx + 1]\n            heappush(min_heap, (next_element, list_idx, element_idx + 1))\n\n            # Update the highest_in_window.\n            highest_in_window = max(highest_in_window, next_element)\n\n        return [widest_range[1], widest_range[2]]"}
{"lang": "python3", "question_id": 639, "question_slug": "decode-ways-ii", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "281 ms", "memory": 15064000, "question_id": "639", "elapsed_time": 301, "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681395925841, "total_correct": 217, "total_testcases": 217, "runtime_percentile": 93.91869999999994, "status_memory": "15.1 MB", "memory_percentile": 83.78379999999999, "pretty_lang": "Python3", "submission_id": "933103903", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        MOD = 10**9 + 7\n        dp1, dp2, dp3 = 1, 0, 0\n        \n        for ch in s:\n            new_dp1 = new_dp2 = new_dp3 = 0\n            \n            if ch == '*':\n                new_dp1 = 9 * dp1 + 9 * dp2 + 6 * dp3\n                new_dp2 = dp1\n                new_dp3 = dp1\n            else:\n                new_dp1 = (ch > '0') * dp1 + dp2 + (ch <= '6') * dp3\n                new_dp2 = (ch == '1') * dp1\n                new_dp3 = (ch == '2') * dp1\n            \n            dp1, dp2, dp3 = new_dp1 % MOD, new_dp2, new_dp3\n        \n        return dp1"}
{"lang": "python3", "question_id": 664, "question_slug": "strange-printer", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "516 ms", "memory": 15548000, "question_id": "664", "elapsed_time": 528, "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681396026528, "total_correct": 200, "total_testcases": 200, "runtime_percentile": 61.311599999999714, "status_memory": "15.5 MB", "memory_percentile": 50.00000000000001, "pretty_lang": "Python3", "submission_id": "933104740", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "class Solution:\n    def strangePrinter(self, s: str) -> int:\n        def dp(i, j):\n            if i > j:\n                return 0\n            if memo[i][j]:\n                return memo[i][j]\n            ans = dp(i+1, j) + 1\n            for k in range(i+1, j+1):\n                if s[k] == s[i]:\n                    ans = min(ans, dp(i, k-1) + dp(k+1, j))\n            memo[i][j] = ans\n            return ans\n        \n        memo = [[0] * 101 for _ in range(101)]\n        return dp(0, len(s) - 1)"}
{"lang": "python3", "question_id": 668, "question_slug": "kth-smallest-number-in-multiplication-table", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "889 ms", "memory": 13860000, "question_id": "668", "elapsed_time": 904, "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681396132640, "total_correct": 70, "total_testcases": 70, "runtime_percentile": 84.01899999999983, "status_memory": "13.9 MB", "memory_percentile": 66.8949, "pretty_lang": "Python3", "submission_id": "933105632", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "class Solution:\n    def findKthNumber(self, m: int, n: int, k: int) -> int:\n        def count(x: int) -> int:\n            return sum(min(x // i, n) for i in range(1, m + 1))\n\n        low, high = 1, m * n\n        while low < high:\n            mid = low + (high - low) // 2\n            if count(mid) >= k:\n                high = mid\n            else:\n                low = mid + 1\n        \n        return low"}
{"lang": "python3", "question_id": 675, "question_slug": "cut-off-trees-for-golf-event", "status": "Runtime Error", "reward": false, "done": false, "submission_result": {"status_code": 15, "lang": "python3", "run_success": false, "runtime_error": "Line 7: SyntaxError: unterminated string literal (detected at line 57)", "full_runtime_error": "SyntaxError: unterminated string literal (detected at line 57)\n                                                                                                                 ^\n    A number greater than `1` represents a tree in a cell that can be walked through, and this number is the tree's height.\nLine 7  (Solution.py)", "status_runtime": "N/A", "memory": 8896000, "question_id": "675", "elapsed_time": 17, "compare_result": "0000000000000000000000000000000000000000000000000000000", "code_output": "", "std_output": "", "last_testcase": "[[1,2,3],[0,0,4],[7,6,5]]", "expected_output": "6", "task_finish_time": 1681396711503, "total_correct": 0, "total_testcases": 55, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933110424", "status_msg": "Runtime Error", "state": "SUCCESS"}, "code": "Cut Off Trees for Golf Event:\nYou are asked to cut off all the trees in a forest for a golf event. The forest is represented as an `m x n` matrix. In this matrix:\n`0` means the cell cannot be walked through.\n\n`1` represents an empty cell that can be walked through.\n\nA number greater than `1` represents a tree in a cell that can be walked through, and this number is the tree's height.\n\nIn one step, you can walk in any of the four directions: north, east, south, and west. If you are standing in a cell with a tree, you can choose whether to cut it off.\n\nYou must cut off the trees in order from shortest to tallest. When you cut off a tree, the value at its cell becomes `1` (an empty cell).\n\nStarting from the point `(0, 0)`, return the minimum steps you need to walk to cut off all the trees. If you cannot cut off all the trees, return `-1`.\n\nYou are guaranteed that no two trees have the same height, and there is at least one tree needs to be cut off.\n\n\nExample 1:\nInput: forest = [[1,2,3],[0,0,4],[7,6,5]]\nOutput: 6\nExplanation: Following the path above allows you to cut off the trees from shortest to tallest in 6 steps.\n\n\nExample 2:\nInput: forest = [[1,2,3],[0,0,0],[7,6,5]]\nOutput: -1\nExplanation: The trees in the bottom row cannot be accessed as the middle row is blocked.\n\n\nExample 3:\nInput: forest = [[2,3,4],[0,0,5],[8,7,6]]\nOutput: 6\n\nExplanation: You can follow the same path as Example 1 to cut off all the trees.\n\nNote that you can cut off the first tree at (0, 0) before making any steps.\n\n\nConstraints:\n`m == forest.length`\n`n == forest[i].length`\n`1 <= m, n <= 50`\n`0 <= forest[i][j] <= 109`\n\nCode:\n```python3\nclass Solution:\n    def cutOffTree(self, forest: List[List[int]]) -> int:\n        \n```"}
{"lang": "python3", "question_id": 679, "question_slug": "24-game", "status": "Time Limit Exceeded", "reward": false, "done": false, "submission_result": {"status_code": 14, "lang": "python3", "run_success": false, "status_runtime": "N/A", "memory": 783184000, "question_id": "679", "elapsed_time": 2016, "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000", "code_output": "", "std_output": "", "last_testcase": "[4,1,8,7]", "expected_output": "true", "task_finish_time": 1681397005026, "total_correct": 0, "total_testcases": 71, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933112908", "status_msg": "Time Limit Exceeded", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def judgePoint24(self, cards: List[int]) -> bool:\n        def dfs(nums: List[float]) -> bool:\n            if not nums:\n                return False\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < 1e-6\n            \n            for i, x in enumerate(nums):\n                for j, y in enumerate(nums[:i]+nums[i+1:]):\n                    next_nums = nums[:i] + nums[i+1:j] + nums[j+1:]\n                    \n                    for op in [1, 2, 3, 4]:\n                        if (op != 4 or x > y) and (op != 3 or x != 0) and (op != 2 or x != y):\n                            if dfs(next_nums + [x + y if op == 1 else x - y if op == 2\n                                             else x * y if op == 3 else x / y]) or \\\n                               dfs(next_nums + [y - x if op == 1 else y * x if op == 3 else y / x]):\n\n                                return True\n            return False\n        \n        return dfs([float(x) for x in cards])"}
{"lang": "python3", "question_id": 685, "question_slug": "redundant-connection-ii", "status": "Runtime Error", "reward": false, "done": false, "submission_result": {"status_code": 15, "lang": "python3", "run_success": false, "runtime_error": "Line 56: NameError: name 'Solution' is not defined", "full_runtime_error": "NameError: name 'Solution' is not defined\n    ret = Solution().findRedundantDirectedConnection(param_1)\nLine 56 in _driver (Solution.py)\n    _driver()\nLine 67 in <module> (Solution.py)", "status_runtime": "N/A", "memory": 13852000, "question_id": "685", "elapsed_time": 43, "compare_result": "0000000000000000000000000000000000000000000000000000000", "code_output": "", "std_output": "", "last_testcase": "[[1,2],[1,3],[2,3]]", "expected_output": "[2,3]", "task_finish_time": 1681397603604, "total_correct": 0, "total_testcases": 55, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933118032", "status_msg": "Runtime Error", "state": "SUCCESS"}, "code": "from typing import List\n\ndef findRedundantDirectedConnection(edges: List[List[int]]) -> List[int]:\n    n = len(edges)\n    parent = [0] * (n+1)\n    cand1 = cand2 = None\n    \n    # Step 1: Detect edge causing node with 2 parents\n    for idx, (u, v) in enumerate(edges):\n        if parent[v] == 0:\n            parent[v] = u\n        else:\n            cand1 = [parent[v], v] # The first added edge causing the problem\n            cand2 = [u, v] # The second added edge causing the problem\n            edges[idx] = None # Remove the problematic edge\n            break\n    \n    # Step 2: Run the Union-Find algorithm\n    def find(x: int) -> int:\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    for u, v in edges:\n        if u is None: continue\n        if v is None: continue\n        \n        root_u = find(u)\n        root_v = find(v)\n        \n        # Cycle detected\n        if root_u == root_v:\n            return cand1 if cand1 else [u, v]\n        \n        parent[root_v] = root_u\n    \n    return cand2"}
{"lang": "python3", "question_id": 685, "question_slug": "redundant-connection-ii", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "58 ms", "memory": 14408000, "question_id": "685", "elapsed_time": 74, "compare_result": "1111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681398193172, "total_correct": 55, "total_testcases": 55, "runtime_percentile": 91.38600000000002, "status_memory": "14.4 MB", "memory_percentile": 64.79400000000001, "pretty_lang": "Python3", "submission_id": "933122873", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n        n = len(edges)\n        parents = [0] * (n + 1)\n        candidates = []\n        for edge in edges:\n            if parents[edge[1]] == 0:\n                parents[edge[1]] = edge[0]\n            else:\n                candidates.append([parents[edge[1]], edge[1]])\n                candidates.append(edge)\n                break\n\n        roots = list(range(n + 1))\n        \n        def find(ii):\n            if roots[ii] != ii:\n                roots[ii] = find(roots[ii])\n            return roots[ii]\n        \n        # If there is no edge with two parents, the added edge must be the last one forming a cycle\n        if not candidates:\n            for edge in edges:\n                ui, vi = edge\n                if find(ui) == find(vi):\n                    return edge\n                roots[find(ui)] = find(vi)\n        else:\n            # If removing the second candidate results in a valid tree, return it; otherwise, return the first one\n            for edge in edges:\n                if edge == candidates[1]:\n                    continue\n                ui, vi = edge\n                if find(ui) == find(vi):\n                    return candidates[0]\n                roots[find(ui)] = find(vi)\n            return candidates[1]"}
{"lang": "python3", "question_id": 689, "question_slug": "maximum-sum-of-3-non-overlapping-subarrays", "status": "Wrong Answer", "reward": false, "done": false, "submission_result": {"status_code": 11, "lang": "python3", "run_success": true, "status_runtime": "N/A", "memory": 13772000, "question_id": "689", "elapsed_time": 43, "compare_result": "0000000000000000000000000000000000000000000", "code_output": "[4,4,0]", "std_output": "", "last_testcase": "[1,2,1,2,6,7,5,1]\n2", "expected_output": "[0,3,5]", "task_finish_time": 1681399993779, "total_correct": 0, "total_testcases": 43, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933137413", "input_formatted": "[1,2,1,2,6,7,5,1], 2", "input": "[1,2,1,2,6,7,5,1]\n2", "status_msg": "Wrong Answer", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n\n        def max_k_subarray_sum(arr: List[int], k: int):\n            n = len(arr)\n            max_sum = sum(arr[:k])\n            cum_sum = max_sum\n            idx = 0\n            for i in range(1, n - k + 1):\n                cum_sum = cum_sum - arr[i - 1] + arr[i + k - 1]\n                if cum_sum > max_sum:\n                    max_sum = cum_sum\n                    idx = i\n            return idx, max_sum\n\n        n = len(nums)\n        dp = [[0]*n for _ in range(4)]\n        sub_sum = [0]*n\n        for i in range(1, 4):\n            for j in range((i-1)*k, n-i*k+1):\n                idx, max_sum = max_k_subarray_sum(nums[j:], k)\n                max_sum += dp[i-1][j-1] if j > 0 else 0\n                dp[i][j] = max(max_sum, dp[i][j-1]) if j > 0 else max_sum\n                sub_sum[j] = idx + j\n\n        ans = []\n        for i in range(3, 0, -1):\n            ans.append(sub_sum.pop())\n            sub_sum = sub_sum[:i*k-len(ans)]\n        ans.reverse()\n\n        return ans"}
{"lang": "python3", "question_id": 691, "question_slug": "stickers-to-spell-word", "status": "Runtime Error", "reward": false, "done": false, "submission_result": {"status_code": 15, "lang": "python3", "run_success": false, "runtime_error": "Line 49: NameError: name 'Solution' is not defined", "full_runtime_error": "NameError: name 'Solution' is not defined\n    ret = Solution().minStickers(param_1, param_2)\nLine 49 in _driver (Solution.py)\n    _driver()\nLine 60 in <module> (Solution.py)", "status_runtime": "N/A", "memory": 13776000, "question_id": "691", "elapsed_time": 42, "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "code_output": "", "std_output": "", "last_testcase": "[\"with\",\"example\",\"science\"]\n\"thehat\"", "expected_output": "3", "task_finish_time": 1681400121980, "total_correct": 0, "total_testcases": 101, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933138471", "status_msg": "Runtime Error", "state": "SUCCESS"}, "code": "from typing import List\n\ndef minStickers(stickers: List[str], target: str) -> int:\n    from collections import Counter, defaultdict\n    \n    def min_stickers_rec(bag):\n        sticker_count = 0\n        remaining = bag - Counter('')\n        for i in range(len(stickers)):\n            sticker_left = stickers[i] - remaining\n            if sticker_left != '-1':\n                bag_remaining = remaining - stickers[i]\n                stickers_rem = stickers[:]\n                del stickers_rem[i]\n                candidate_sticker_count = 1 + min_stickers_rec(Counter(sticker_left), stickers_rem)\n                if sticker_count == 0 or candidate_sticker_count < sticker_count:\n                    sticker_count = candidate_sticker_count\n        return sticker_count\n\n    stickers = [dict(Counter(sticker)) for sticker in stickers]\n    target_bag = Counter(target)\n    \n    min_candidates = min_stickers_rec(target_bag)\n    \n    return min_candidates if min_candidates else -1"}
{"lang": "python3", "question_id": 699, "question_slug": "falling-squares", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "547 ms", "memory": 14596000, "question_id": "699", "elapsed_time": 563, "compare_result": "1111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681400386271, "total_correct": 46, "total_testcases": 46, "runtime_percentile": 26.61990000000005, "status_memory": "14.6 MB", "memory_percentile": 63.6362, "pretty_lang": "Python3", "submission_id": "933140550", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def fallingSquares(self, positions: List[List[int]]) -> List[int]:\n        heights = []\n        for i, (left, side) in enumerate(positions):\n            height = side\n            for j in range(i):\n                l, s = positions[j]\n                if l < left + side and left < l + s: \n                    height = max(height, heights[j] + side)\n            heights.append(height)\n        max_heights = []\n        for h in heights:\n            max_heights.append(max(max_heights[-1] if max_heights else 0, h))\n        return max_heights"}
{"lang": "python3", "question_id": 715, "question_slug": "range-module", "status": "Runtime Error", "reward": false, "done": false, "submission_result": {"status_code": 15, "lang": "python3", "run_success": false, "runtime_error": "Line 4: SyntaxError: closing parenthesis ')' does not match opening parenthesis '['", "full_runtime_error": "SyntaxError: closing parenthesis ')' does not match opening parenthesis '['\n                                                                             ^\n    `addRange(int left, int right)` Adds the half-open interval `[left, right)`, tracking every real number in that interval.  Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval `[left, right)` that are not already tracked.\nLine 4  (Solution.py)", "status_runtime": "N/A", "memory": 8904000, "question_id": "715", "elapsed_time": 17, "compare_result": "000000000000000000000000000000000000000000000000000000", "code_output": "", "std_output": "", "last_testcase": "[\"RangeModule\",\"addRange\",\"removeRange\",\"queryRange\",\"queryRange\",\"queryRange\"]\n[[],[10,20],[14,16],[10,14],[13,15],[16,17]]", "expected_output": "[null,null,null,true,false,true]", "task_finish_time": 1681403340196, "total_correct": 0, "total_testcases": 54, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933165618", "status_msg": "Runtime Error", "state": "SUCCESS"}, "code": "Range Module:\nA Range Module is a module that tracks ranges of numbers. Your task is to design and implement the following interfaces in an efficient manner.\n\n`addRange(int left, int right)` Adds the half-open interval `[left, right)`, tracking every real number in that interval.  Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval `[left, right)` that are not already tracked.\n\n`queryRange(int left, int right)` Returns true if and only if every real number in the interval `[left, right)`\n is currently being tracked.\n\n`removeRange(int left, int right)` Stops tracking every real number currently being tracked in the interval `[left, right)`.\n\n\nExample 1:\naddRange(10, 20): null\nremoveRange(14, 16): null\nqueryRange(10, 14): true (Every number in [10, 14) is being tracked)\nqueryRange(13, 15): false (Numbers like 14, 14.03, 14.17 in [13, 15) are not being tracked)\nqueryRange(16, 17): true (The number 16 in [16, 17) is still being tracked, despite the remove operation)\nNote:\nA half open interval `[left, right)` denotes all real numbers `left <= x < right`.\n\n`0 < left < right < 10^9` in all calls to `addRange, queryRange, removeRange`.\n\nThe total number of calls to `addRange` in a single test case is at most `1000`.\n\nThe total number of calls to `queryRange` in a single test case is at most `5000`.\n\nThe total number of calls to `removeRange` in a single test case is at most `1000`.\n\nCode:\n```python3\nclass RangeModule:\n\n    def __init__(self):\n        \n\n    def addRange(self, left: int, right: int) -> None:\n        \n\n    def queryRange(self, left: int, right: int) -> bool:\n        \n\n    def removeRange(self, left: int, right: int) -> None:\n        \n\n\n# Your RangeModule object will be instantiated and called as such:\n# obj = RangeModule()\n# obj.addRange(left,right)\n# param_2 = obj.queryRange(left,right)\n# obj.removeRange(left,right)\n```"}
{"lang": "python3", "question_id": 719, "question_slug": "find-k-th-smallest-pair-distance", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "109 ms", "memory": 14848000, "question_id": "719", "elapsed_time": 130, "compare_result": "1111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681403584004, "total_correct": 19, "total_testcases": 19, "runtime_percentile": 96.21620000000001, "status_memory": "14.8 MB", "memory_percentile": 89.7297, "pretty_lang": "Python3", "submission_id": "933167637", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "from typing import List\n\nclass Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        def count_pairs(distance: int) -> int:\n            count = 0\n            left = 0\n            for right in range(1, len(nums)):\n                while nums[right] - nums[left] > distance:\n                    left += 1\n                count += right - left\n            return count\n\n        nums.sort()\n        low, high = 0, nums[-1] - nums[0]\n\n        while low < high:\n            mid = low + (high - low) // 2\n            if count_pairs(mid) < k:\n                low = mid + 1\n            else:\n                high = mid\n\n        return low"}
{"lang": "python3", "question_id": 726, "question_slug": "number-of-atoms", "status": "Runtime Error", "reward": false, "done": false, "submission_result": {"status_code": 15, "lang": "python3", "run_success": false, "runtime_error": "Line 48: NameError: name 'Solution' is not defined", "full_runtime_error": "NameError: name 'Solution' is not defined\n    ret = Solution().countOfAtoms(param_1)\nLine 48 in _driver (Solution.py)\n    _driver()\nLine 59 in <module> (Solution.py)", "status_runtime": "N/A", "memory": 13896000, "question_id": "726", "elapsed_time": 48, "compare_result": "00000000000000000000000000000000", "code_output": "", "std_output": "", "last_testcase": "\"H2O\"", "expected_output": "\"H2O\"", "task_finish_time": 1681403811296, "total_correct": 0, "total_testcases": 32, "runtime_percentile": null, "status_memory": "N/A", "memory_percentile": null, "pretty_lang": "Python3", "submission_id": "933169639", "status_msg": "Runtime Error", "state": "SUCCESS"}, "code": "import re\nfrom collections import defaultdict\n\ndef count_of_atoms(formula: str) -> str:\n\n    if not (1 <= len(formula) <= 1000) or not re.fullmatch(r\"\\A[A-Z][a-z]*(\\d+([A-Z])?[a-z]*(\\d)?)?(\\([A-Z][a-z]*(\\d+([A-Z])?[a-z]*(\\d)?)?\\)(\\d)?)?\\Z\", formula):\n        raise ValueError(\"Invalid formula.\")\n    \n    formula = list(formula)\n    count_dict = defaultdict(int)\n\n    def count_atoms(multiplier: int) -> None:\n        while (\n                len(formula) != 0 \n                and formula[0] != \")\"\n                and (not formula[0].isdigit() or len(formula) == 1 or not formula[1].isupper())\n        ):\n            if formula.pop(0) == \"(\":\n                count_atoms(1)\n            else:\n                atom = formula.pop(0)\n                if formula and formula[0].islower():\n                    atom += formula.pop(0)\n                count_dict[atom] += (\n                    int(\"\".join(takewhile(str.isdigit, formula))) if formula[0].isdigit() else 1\n                ) * multiplier\n\n    count_atoms(1)\n    return \"\".join(atom + (str(count) if count > 1 else \"\") for atom, count in sorted(count_dict.items()))"}
{"lang": "python3", "question_id": 730, "question_slug": "count-different-palindromic-subsequences", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "1899 ms", "memory": 36816000, "question_id": "730", "elapsed_time": 1962, "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681403926842, "total_correct": 367, "total_testcases": 367, "runtime_percentile": 40.105400000000216, "status_memory": "36.8 MB", "memory_percentile": 83.5164, "pretty_lang": "Python3", "submission_id": "933170680", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "class Solution:\n    def countPalindromicSubsequences(self, s: str) -> int:\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(n):\n            dp[i][i] = 1\n\n        for l in range(1, n):\n            for i in range(n - l):\n                j = i + l\n\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] * 2\n\n                    l_idx, r_idx = i + 1, j - 1\n                    while l_idx <= r_idx and s[l_idx] != s[i]:\n                        l_idx += 1\n                    while l_idx <= r_idx and s[r_idx] != s[j]:\n                        r_idx -= 1\n\n                    if l_idx > r_idx:\n                        dp[i][j] += 2\n                    elif l_idx == r_idx:\n                        dp[i][j] += 1\n                    else:\n                        dp[i][j] -= dp[l_idx + 1][r_idx - 1]\n\n                else:\n                    dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j -1]\n                \n                dp[i][j] = (dp[i][j] + 1000000007) % 1000000007\n\n        return dp[0][n-1]"}
{"lang": "python3", "question_id": 732, "question_slug": "my-calendar-iii", "status": "Accepted", "reward": true, "done": true, "submission_result": {"status_code": 10, "lang": "python3", "run_success": true, "status_runtime": "1660 ms", "memory": 14404000, "question_id": "732", "elapsed_time": 1674, "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111", "code_output": "", "std_output": "", "last_testcase": "", "expected_output": "", "task_finish_time": 1681404066722, "total_correct": 98, "total_testcases": 98, "runtime_percentile": 33.64340000000028, "status_memory": "14.4 MB", "memory_percentile": 66.8223, "pretty_lang": "Python3", "submission_id": "933171984", "status_msg": "Accepted", "state": "SUCCESS"}, "code": "class MyCalendarThree:\n\n    def __init__(self):\n        self.timeline = {}\n\n    def book(self, start: int, end: int) -> int:\n        self.timeline[start] = self.timeline.get(start, 0) + 1\n        self.timeline[end] = self.timeline.get(end, 0) - 1\n        ongoing = max_k = 0\n\n        for count in sorted(self.timeline):\n            ongoing += self.timeline[count]\n            max_k = max(max_k, ongoing)\n\n        return max_k"}
